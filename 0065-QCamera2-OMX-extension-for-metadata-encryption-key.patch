From 7027fc059c1e521730e6c8ee645efb7bb3f4f348 Mon Sep 17 00:00:00 2001
From: Kamen Kirov <kkirov@codeaurora.org>
Date: Fri, 6 Sep 2013 12:44:29 -0700
Subject: [PATCH 065/176] QCamera2: OMX extension for metadata encryption key

1. Adds an OMX extension to pass the metadata encryption key.
2. Adds ability to read encryption key from a file.

Change-Id: Ida349adc5fb5ef19eb7c9e7aa15ee1bde5c56df6
---
 QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h |  3 +
 QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c | 93 ++++++++++++++++++++++++++
 mm-image-codec/qomx_core/QOMX_JpegExtensions.h | 13 ++++
 3 files changed, 109 insertions(+)

diff --git a/QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h b/QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h
index 5c18292..23f3f74 100644
--- a/QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h
+++ b/QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h
@@ -316,6 +316,9 @@ typedef struct mm_jpeg_job_session {
   OMX_EVENTTYPE omxEvent;
   int event_pending;
 
+  uint8_t *meta_enc_key;
+  uint32_t meta_enc_keylen;
+
   struct mm_jpeg_job_session *next_session;
 
   uint32_t curr_out_buf_idx;
diff --git a/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c b/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
index 57dde82..5c516b1 100644
--- a/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
+++ b/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
@@ -47,6 +47,8 @@
 
 #define ENCODING_MODE_PARALLEL 1
 
+#define META_KEYFILE "/data/metadata.key"
+
 OMX_ERRORTYPE mm_jpeg_ebd(OMX_HANDLETYPE hComponent,
     OMX_PTR pAppData,
     OMX_BUFFERHEADERTYPE* pBuffer);
@@ -356,6 +358,11 @@ void mm_jpeg_session_destroy(mm_jpeg_job_session_t* p_session)
   pthread_mutex_destroy(&p_session->lock);
   pthread_cond_destroy(&p_session->cond);
 
+  if (NULL != p_session->meta_enc_key) {
+    free(p_session->meta_enc_key);
+    p_session->meta_enc_key = NULL;
+  }
+
   // Destroy next session
   if (p_session->next_session) {
     mm_jpeg_session_destroy(p_session->next_session);
@@ -511,6 +518,51 @@ OMX_ERRORTYPE mm_jpeg_metadata(
   return OMX_ErrorNone;
 }
 
+/** mm_jpeg_meta_enc_key:
+ *
+ *  Arguments:
+ *    @p_session: job session
+ *
+ *  Return:
+ *       OMX error values
+ *
+ *  Description:
+ *       Pass metadata encrypt key
+ *
+ **/
+OMX_ERRORTYPE mm_jpeg_meta_enc_key(
+  mm_jpeg_job_session_t* p_session)
+{
+  OMX_ERRORTYPE rc = OMX_ErrorNone;
+  OMX_INDEXTYPE indexType;
+  mm_jpeg_encode_params_t *p_params = &p_session->params;
+  mm_jpeg_encode_job_t *p_jobparams = &p_session->encode_job;
+  QOMX_META_ENC_KEY lKey;
+
+  lKey.metaKey = p_session->meta_enc_key;
+  lKey.keyLen = p_session->meta_enc_keylen;
+
+  if ((!lKey.metaKey) || (!lKey.keyLen)){
+    CDBG_ERROR("%s:%d] Key is invalid", __func__, __LINE__);
+    return OMX_ErrorNone;
+  }
+
+  rc = OMX_GetExtensionIndex(p_session->omx_handle,
+      QOMX_IMAGE_EXT_META_ENC_KEY_NAME, &indexType);
+
+  if (rc != OMX_ErrorNone) {
+    CDBG_ERROR("%s:%d] Failed", __func__, __LINE__);
+    return rc;
+  }
+
+  rc = OMX_SetConfig(p_session->omx_handle, indexType, &lKey);
+  if (rc != OMX_ErrorNone) {
+    CDBG_ERROR("%s:%d] Failed", __func__, __LINE__);
+    return rc;
+  }
+  return OMX_ErrorNone;
+}
+
 /** map_jpeg_format:
  *
  *  Arguments:
@@ -920,6 +972,13 @@ OMX_ERRORTYPE mm_jpeg_session_config_main(mm_jpeg_job_session_t *p_session)
     return rc;
   }
 
+  /* set the metadata encrypt key */
+  rc = mm_jpeg_meta_enc_key(p_session);
+  if (OMX_ErrorNone != rc) {
+    CDBG_ERROR("%s: config session failed", __func__);
+    return rc;
+  }
+
   return rc;
 }
 
@@ -1871,7 +1930,34 @@ abort_done:
 }
 
 
+static int32_t mm_jpeg_read_meta_keyfile(mm_jpeg_job_session_t *p_session, const char *filename)
+{
+  int rc = 0;
+  FILE *fp = NULL;
+  int file_size = 0;
+  fp = fopen(filename, "r");
+  if (!fp) {
+    CDBG_ERROR("%s:%d] Key not present", __func__, __LINE__);
+    return -1;
+  }
+  fseek(fp, 0, SEEK_END);
+  file_size = ftell(fp);
+  fseek(fp, 0, SEEK_SET);
+
+  p_session->meta_enc_key = (uint8_t *) malloc((file_size + 1) * sizeof(uint8_t));
+
+  if (!p_session->meta_enc_key) {
+    CDBG_ERROR("%s:%d] error", __func__, __LINE__);
+    return -1;
+  }
+
+  fread(p_session->meta_enc_key, 1, file_size, fp);
+  fclose(fp);
+
+  p_session->meta_enc_keylen = file_size;
 
+  return rc;
+}
 
 /** mm_jpeg_create_session:
  *
@@ -2021,6 +2107,13 @@ int32_t mm_jpeg_create_session(mm_jpeg_obj *my_obj,
     mm_jpeg_queue_enq(p_out_buf_q, (void *)(i+1));
   }
 
+  p_session->meta_enc_key = NULL;
+  p_session->meta_enc_keylen = 0;
+
+#ifdef MM_JPEG_READ_META_KEYFILE
+  mm_jpeg_read_meta_keyfile(p_session, META_KEYFILE);
+#endif
+
   return rc;
 }
 
diff --git a/mm-image-codec/qomx_core/QOMX_JpegExtensions.h b/mm-image-codec/qomx_core/QOMX_JpegExtensions.h
index e6b9d3f..3244856 100644
--- a/mm-image-codec/qomx_core/QOMX_JpegExtensions.h
+++ b/mm-image-codec/qomx_core/QOMX_JpegExtensions.h
@@ -57,6 +57,7 @@ typedef enum {
 #define QOMX_IMAGE_EXT_ENCODING_MODE_NAME        "OMX.QCOM.image.encoding.mode"
 #define QOMX_IMAGE_EXT_WORK_BUFFER_NAME      "OMX.QCOM.image.exttype.workbuffer"
 #define QOMX_IMAGE_EXT_METADATA_NAME      "OMX.QCOM.image.exttype.metadata"
+#define QOMX_IMAGE_EXT_META_ENC_KEY_NAME      "OMX.QCOM.image.exttype.metaEncKey"
 
 /** QOMX_IMAGE_EXT_INDEXTYPE
 *  This enum is an extension of the OMX_INDEXTYPE enum and
@@ -87,6 +88,9 @@ typedef enum {
   //Name: OMX.QCOM.image.exttype.metadata
   QOMX_IMAGE_EXT_METADATA = 0x07F00008,
 
+  //Name: OMX.QCOM.image.exttype.metaEncKey
+  QOMX_IMAGE_EXT_META_ENC_KEY = 0x07F00009,
+
 } QOMX_IMAGE_EXT_INDEXTYPE;
 
 /** QOMX_BUFFER_INFO
@@ -210,6 +214,15 @@ typedef struct {
   OMX_U32 metaPayloadSize;
 } QOMX_METADATA;
 
+/**QOMX_META_ENC_KEY
+ *
+ * meta data encryption key
+ */
+typedef struct {
+  OMX_U8  *metaKey;
+  OMX_U32 keyLen;
+} QOMX_META_ENC_KEY;
+
 /** QOMX_IMG_COLOR_FORMATTYPE
 *  This enum is an extension of the OMX_COLOR_FORMATTYPE enum.
 *  It specifies Qcom supported color formats.
-- 
1.8.3.1

