From 3c1c2ad89aa55970dc4386a37f3aee63694d2a5d Mon Sep 17 00:00:00 2001
From: Jeyaprakash Soundrapandian <jsoundra@codeaurora.org>
Date: Thu, 15 Aug 2013 11:16:09 -0700
Subject: [PATCH 023/176] QCamera2: socket communication to chromatix

The chromatix light use the camera test app,
the socket communication is added to support the host
sending buffer.
Fix issues for chromatix light.

Change-Id: I9d0bc00eabf38f5cffc01d73f3f3a0839c59fe5d
---
 QCamera2/stack/mm-camera-test/Android.mk           |   8 +-
 QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h |  29 +-
 .../stack/mm-camera-test/inc/mm_qcamera_commands.h |  67 ++
 .../stack/mm-camera-test/inc/mm_qcamera_socket.h   | 125 +++
 QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c |  17 +-
 .../stack/mm-camera-test/src/mm_qcamera_commands.c | 291 +++++++
 .../mm-camera-test/src/mm_qcamera_main_menu.c      |   5 +-
 .../stack/mm-camera-test/src/mm_qcamera_preview.c  |   1 -
 .../stack/mm-camera-test/src/mm_qcamera_socket.c   | 862 +++++++++++++++++++++
 9 files changed, 1386 insertions(+), 19 deletions(-)
 create mode 100644 QCamera2/stack/mm-camera-test/inc/mm_qcamera_commands.h
 create mode 100644 QCamera2/stack/mm-camera-test/inc/mm_qcamera_socket.h
 mode change 100755 => 100644 QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
 create mode 100755 QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c
 mode change 100755 => 100644 QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c
 create mode 100644 QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c

diff --git a/QCamera2/stack/mm-camera-test/Android.mk b/QCamera2/stack/mm-camera-test/Android.mk
index 6fcad22..fb34b0d 100644
--- a/QCamera2/stack/mm-camera-test/Android.mk
+++ b/QCamera2/stack/mm-camera-test/Android.mk
@@ -26,7 +26,9 @@ LOCAL_SRC_FILES:= \
         src/mm_qcamera_snapshot.c \
         src/mm_qcamera_rdi.c \
         src/mm_qcamera_reprocess.c\
-        src/mm_qcamera_queue.c
+        src/mm_qcamera_queue.c \
+        src/mm_qcamera_socket.c \
+        src/mm_qcamera_commands.c
 #        src/mm_qcamera_dual_test.c \
 
 LOCAL_C_INCLUDES:=$(LOCAL_PATH)/inc
@@ -114,7 +116,9 @@ LOCAL_SRC_FILES:= \
         src/mm_qcamera_snapshot.c \
         src/mm_qcamera_rdi.c \
         src/mm_qcamera_reprocess.c\
-        src/mm_qcamera_queue.c
+        src/mm_qcamera_queue.c \
+        src/mm_qcamera_socket.c \
+        src/mm_qcamera_commands.c
 #        src/mm_qcamera_dual_test.c \
 
 LOCAL_C_INCLUDES:=$(LOCAL_PATH)/inc
diff --git a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
index d70ed7f..f5a8b7e 100644
--- a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
+++ b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
@@ -43,6 +43,7 @@
 
 #include "mm_camera_interface.h"
 #include "mm_jpeg_interface.h"
+#include "mm_qcamera_socket.h"
 
 #define MM_QCAMERA_APP_INTERATION 1
 
@@ -113,10 +114,18 @@ typedef enum {
 typedef void (*prev_callback) (mm_camera_buf_def_t *preview_frame);
 
 typedef struct {
-	int (*command_process) (void *recv, mm_camera_tune_cmd_t cmd, void *param);
-    int (*prevcommand_process) (void *recv, mm_camera_tune_prevcmd_t cmd, void *param);
+  char *send_buf;
+  uint32_t send_len;
+  void *next;
+} eztune_prevcmd_rsp;
+
+typedef struct {
+    int (*command_process) (void *recv, mm_camera_tune_cmd_t cmd,
+      void *param, char *send_buf, uint32_t send_len);
+    int (*prevcommand_process) (void *recv, mm_camera_tune_prevcmd_t cmd,
+      void *param, char **send_buf, uint32_t *send_len);
     void (*prevframe_callback) (mm_camera_buf_def_t *preview_frame);
-}mm_camera_tune_func_t;
+} mm_camera_tune_func_t;
 
 typedef struct {
     mm_camera_tune_func_t *func_tbl;
@@ -309,11 +318,19 @@ typedef struct {
 } mm_camera_lib_params;
 
 typedef struct {
+  tuneserver_protocol_t *proto;
+  int clientsocket_id;
+  prserver_protocol_t *pr_proto;
+  int pr_clientsocket_id;
+  mm_camera_tuning_lib_params_t tuning_params;
+} tuningserver_t;
+
+typedef struct {
     mm_camera_app_t app_ctx;
     mm_camera_test_obj_t test_obj;
     mm_camera_lib_params current_params;
     int stream_running;
-    mm_camera_tuning_lib_params_t tuning_params;
+    tuningserver_t tsctrl;
 } mm_camera_lib_ctx;
 
 typedef mm_camera_lib_ctx mm_camera_lib_handle;
@@ -448,8 +465,8 @@ int mm_camera_lib_send_command(mm_camera_lib_handle *handle,
 int mm_camera_lib_stop_stream(mm_camera_lib_handle *handle);
 int mm_camera_lib_number_of_cameras(mm_camera_lib_handle *handle);
 int mm_camera_lib_close(mm_camera_lib_handle *handle);
-int32_t mm_camera_load_tuninglibrary
-    (mm_camera_tuning_lib_params_t *tuning_param);
+int32_t mm_camera_load_tuninglibrary(
+  mm_camera_tuning_lib_params_t *tuning_param);
 int mm_camera_lib_set_preview_usercb(
   mm_camera_lib_handle *handle, prev_callback cb);
 //
diff --git a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_commands.h b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_commands.h
new file mode 100644
index 0000000..1540c20
--- /dev/null
+++ b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_commands.h
@@ -0,0 +1,67 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MM_QCAMERA_COMMANDS_H__
+#define __MM_QCAMERA_COMMANDS_H__
+
+#include "mm_qcamera_socket.h"
+#include "mm_qcamera_app.h"
+
+int tuneserver_close_cam(mm_camera_lib_handle *lib_handle);
+int tuneserver_stop_cam(mm_camera_lib_handle *lib_handle);
+int tuneserver_open_cam(mm_camera_lib_handle *lib_handle);
+
+int tuneserver_initialize_tuningp(void * ctrl, int client_socket_id,
+  char *send_buf, uint32_t send_len);
+int tuneserver_deinitialize_tuningp(void * ctrl, int client_socket_id,
+  char *send_buf, uint32_t send_len);
+int tuneserver_process_get_list_cmd(void * ctrl, void *recv_cmd,
+  char *send_buf, uint32_t send_len);
+int tuneserver_process_misc_cmd(void * ctrl, void *recv_cmd,
+  char *send_buf, uint32_t send_len);
+int tuneserver_process_get_params_cmd(void * ctrl, void *recv_cmd,
+  char *send_buf, uint32_t send_len);
+int tuneserver_process_set_params_cmd(void * ctrl, void *recv_cmd,
+  char *send_buf, uint32_t send_len);
+
+int tuneserver_initialize_prevtuningp(void * ctrl,
+  int pr_client_socket_id, cam_dimension_t dimension,
+  char **send_buf, uint32_t *send_len);
+int tuneserver_deinitialize_prevtuningp(void * ctrl,
+  char **send_buf, uint32_t *send_len);
+int tuneserver_preview_getinfo(void * ctrl,
+  char **send_buf, uint32_t *send_len);
+int tuneserver_preview_getchunksize(void * ctrl,
+  char **send_buf, uint32_t *send_len);
+int tuneserver_preview_getframe(void * ctrl,
+  char **send_buf, uint32_t *send_len);
+int tuneserver_preview_unsupported(void * ctrl,
+  char **send_buf, uint32_t *send_len);
+
+#endif /*__MM_QCAMERA_COMMANDS_H__*/
diff --git a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_socket.h b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_socket.h
new file mode 100644
index 0000000..c054d63
--- /dev/null
+++ b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_socket.h
@@ -0,0 +1,125 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MM_QCAMERA_SOCKET_H__
+#define __MM_QCAMERA_SOCKET_H__
+
+#include <stdint.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <termios.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <signal.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <linux/socket.h>
+#include <arpa/inet.h>
+#include <utils/Log.h>
+
+#undef __FD_SET
+#define __FD_SET(fd, fdsetp) \
+  (((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] |= (1<<((fd) & 31)))
+
+#undef __FD_CLR
+#define __FD_CLR(fd, fdsetp) \
+  (((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] &= ~(1<<((fd) & 31)))
+
+#undef  __FD_ISSET
+#define __FD_ISSET(fd, fdsetp) \
+  ((((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] & (1<<((fd) & 31))) != 0)
+
+#undef  __FD_ZERO
+#define __FD_ZERO(fdsetp) \
+  (memset (fdsetp, 0, sizeof (*(fd_set *)(fdsetp))))
+
+#define TUNESERVER_MAX_RECV 2048
+#define TUNESERVER_MAX(a, b)  (((a) > (b)) ? (a) : (b))
+
+#define TUNESERVER_GET_LIST 1014
+#define TUNESERVER_GET_PARMS 1015
+#define TUNESERVER_SET_PARMS 1016
+#define TUNESERVER_MISC_CMDS 1021
+
+#define TUNE_PREV_GET_INFO        0x0001
+#define TUNE_PREV_CH_CNK_SIZE     0x0002
+#define TUNE_PREV_GET_PREV_FRAME  0x0003
+#define TUNE_PREV_GET_JPG_SNAP    0x0004
+#define TUNE_PREV_GET_RAW_SNAP    0x0005
+#define TUNE_PREV_GET_RAW_PREV    0x0006
+
+typedef struct {
+  char data[128];
+} tuneserver_misc_cmd;
+
+typedef enum {
+  TUNESERVER_RECV_COMMAND = 1,
+  TUNESERVER_RECV_PAYLOAD_SIZE,
+  TUNESERVER_RECV_PAYLOAD,
+  TUNESERVER_RECV_RESPONSE,
+  TUNESERVERER_RECV_INVALID,
+} tuneserver_recv_cmd_t;
+
+typedef struct {
+  uint16_t          current_cmd;
+  tuneserver_recv_cmd_t next_recv_code;
+  uint32_t          next_recv_len;
+  void              *recv_buf;
+  uint32_t          recv_len;
+  uint32_t          send_len;
+  void              *send_buf;
+} tuneserver_protocol_t;
+
+typedef enum {
+  TUNE_PREV_RECV_COMMAND = 1,
+  TUNE_PREV_RECV_NEWCNKSIZE,
+  TUNE_PREV_RECV_INVALID
+} tune_prev_cmd_t;
+
+typedef struct _eztune_preview_protocol_t {
+  uint16_t         current_cmd;
+  tune_prev_cmd_t  next_recv_code;
+  uint32_t         next_recv_len;
+  int32_t          send_len;
+  char*            send_buf;
+  uint32_t         send_buf_size;
+  uint32_t         new_cnk_size;
+  uint32_t         new_cmd_available;
+} prserver_protocol_t;
+
+
+int eztune_server_start(void *lib_handle);
+
+#endif /*__MM_QCAMERA_SOCKET_H__*/
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
old mode 100755
new mode 100644
index 0507c56..45dbe1a
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
@@ -963,7 +963,6 @@ int setAecLock(mm_camera_test_obj_t *test_obj, int value)
         goto ERROR;
     }
 
-    printf("%s: Setting AECLock value %d \n", __func__, value);
     rc = AddSetParmEntryToBatch(test_obj,
                                 CAM_INTF_PARM_AEC_LOCK,
                                 sizeof(value),
@@ -993,7 +992,6 @@ int setAwbLock(mm_camera_test_obj_t *test_obj, int value)
         goto ERROR;
     }
 
-    printf("%s: Setting AWB Lock value %d \n", __func__, value);
     rc = AddSetParmEntryToBatch(test_obj,
                                 CAM_INTF_PARM_AWB_LOCK,
                                 sizeof(value),
@@ -1875,9 +1873,7 @@ int mm_app_start_regression_test(int run_tc)
     }
 
     if(run_tc) {
-        printf("\tRunning unit test engine only\n");
         rc = mm_app_unit_test_entry(&my_cam_app);
-        printf("\tUnit test engine. EXIT(%d)!!!\n", rc);
         return rc;
     }
 #if 0
@@ -1895,6 +1891,7 @@ int32_t mm_camera_load_tuninglibrary(mm_camera_tuning_lib_params_t *tuning_param
 {
   void *(*tuning_open_lib)(void) = NULL;
 
+  CDBG("%s  %d\n", __func__, __LINE__);
   tuning_param->lib_handle = dlopen("libmmcamera_tuning.so", RTLD_NOW);
   if (!tuning_param->lib_handle) {
     CDBG_ERROR("%s Failed opening libmmcamera_tuning.so\n", __func__);
@@ -1908,15 +1905,18 @@ int32_t mm_camera_load_tuninglibrary(mm_camera_tuning_lib_params_t *tuning_param
     return -EINVAL;
   }
 
+  if (tuning_param->func_tbl) {
+    CDBG_ERROR("%s already loaded tuninglib..", __func__);
+    return 0;
+  }
+
   tuning_param->func_tbl = (mm_camera_tune_func_t *)tuning_open_lib();
   if (!tuning_param->func_tbl) {
     CDBG_ERROR("%s Failed opening library func table ptr\n", __func__);
     return -EINVAL;
   }
 
-  CDBG_ERROR("tuning_param->func_tbl =%p",tuning_param->func_tbl);
-
-  CDBG("exit");
+  CDBG("%s  %d\n", __func__, __LINE__);
   return 0;
 }
 
@@ -2517,10 +2517,9 @@ int mm_camera_lib_set_preview_usercb(
    mm_camera_lib_handle *handle, prev_callback cb)
 {
     if (handle->test_obj.user_preview_cb != NULL) {
-        CDBG_ERROR("%s, already set user preview callbacks...", __func__);
+        CDBG_ERROR("%s, already set preview callbacks\n", __func__);
         return -1;
     }
     handle->test_obj.user_preview_cb = *cb;
-    printf("%s  %d pointer =%p\n", __func__, __LINE__, handle->test_obj.user_preview_cb);
     return 0;
 }
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c
new file mode 100755
index 0000000..890a8cb
--- /dev/null
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c
@@ -0,0 +1,291 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdlib.h>
+#include <cutils/properties.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+#include <mm_qcamera_app.h>
+#include "mm_qcamera_commands.h"
+#include "mm_qcamera_dbg.h"
+
+int tuneserver_initialize_prevtuningp(void * ctrl,
+  int pr_client_socket_id, cam_dimension_t dimension,
+  char **send_buf, uint32_t *send_len)
+{
+  int result = 0;
+  mm_camera_lib_handle *lib_handle = (mm_camera_lib_handle *) ctrl;
+  tuningserver_t *tctrl = &lib_handle->tsctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  if (tctrl->tuning_params.func_tbl->prevcommand_process == NULL) {
+      ALOGE("%s  %d\n", __func__, __LINE__);
+      return -1;
+  }
+
+  result = tctrl->tuning_params.func_tbl->prevcommand_process(
+      NULL, TUNE_PREVCMD_INIT, (void *)&pr_client_socket_id,
+      send_buf, send_len);
+  result = tctrl->tuning_params.func_tbl->prevcommand_process(
+      NULL, TUNE_PREVCMD_SETDIM, (void *)&dimension,
+      send_buf, send_len);
+
+  mm_camera_lib_set_preview_usercb(lib_handle,
+      (tctrl->tuning_params.func_tbl->prevframe_callback));
+
+  return result;
+}
+
+int tuneserver_deinitialize_prevtuningp(void * ctrl,
+    char **send_buf, uint32_t *send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+
+  result = tctrl->tuning_params.func_tbl->prevcommand_process(
+    &tctrl->pr_proto, TUNE_PREVCMD_DEINIT, NULL, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_preview_getinfo(void * ctrl, char **send_buf, uint32_t *send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->prevcommand_process(
+    &tctrl->pr_proto, TUNE_PREVCMD_GETINFO, NULL, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_preview_getchunksize(void * ctrl,
+  char **send_buf, uint32_t *send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->prevcommand_process(
+    &tctrl->pr_proto, TUNE_PREVCMD_GETCHUNKSIZE,
+    (void *)&tctrl->pr_proto->new_cnk_size, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_preview_getframe(void * ctrl,
+  char **send_buf, uint32_t *send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->prevcommand_process(
+    &tctrl->pr_proto, TUNE_PREVCMD_GETFRAME, NULL, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_preview_unsupported(void * ctrl,
+  char **send_buf, uint32_t *send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->prevcommand_process(
+    &tctrl->pr_proto, TUNE_PREVCMD_UNSUPPORTED, NULL, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_initialize_tuningp(void * ctrl, int client_socket_id,
+  char *send_buf, uint32_t send_len)
+{
+  int result = 0;
+  mm_camera_lib_handle *lib_handle = (mm_camera_lib_handle *) ctrl;
+  tuningserver_t *tctrl = &lib_handle->tsctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->command_process(
+    lib_handle, TUNE_CMD_INIT, &client_socket_id, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_deinitialize_tuningp(void * ctrl, int client_socket_id,
+  char *send_buf, uint32_t send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+
+  result = tctrl->tuning_params.func_tbl->command_process(
+    NULL, TUNE_CMD_DEINIT, &client_socket_id, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_process_get_list_cmd(void * ctrl, void *recv_cmd,
+  char *send_buf, uint32_t send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->command_process(
+     recv_cmd, TUNE_CMD_GET_LIST, NULL, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_process_get_params_cmd(void * ctrl, void *recv_cmd,
+  char *send_buf, uint32_t send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->command_process
+    (recv_cmd, TUNE_CMD_GET_PARAMS, NULL, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_process_set_params_cmd(void * ctrl, void *recv_cmd,
+  char *send_buf, uint32_t send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->command_process(
+     recv_cmd, TUNE_CMD_SET_PARAMS, NULL, send_buf, send_len);
+
+  return result;
+}
+
+int tuneserver_process_misc_cmd(void * ctrl, void *recv_cmd,
+  char *send_buf, uint32_t send_len)
+{
+  int result = 0;
+  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = tctrl->tuning_params.func_tbl->command_process(
+     recv_cmd, TUNE_CMD_MISC, NULL, send_buf, send_len);
+
+  return result;
+}
+
+/** tuneserver_close_cam
+ *    @lib_handle: the camera handle object
+ *
+ *  closes the camera
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+int tuneserver_close_cam(mm_camera_lib_handle *lib_handle)
+{
+  int result = 0;
+
+  result = mm_camera_lib_close(lib_handle);
+  if (result < 0) {
+    printf("%s: Camera close failed\n", __func__);
+  } else {
+    printf("Camera is closed \n");
+  }
+  return result;
+}
+#if 0
+/** tuneserver_start_cam
+ *    @lib_handle: the camera handle object
+ *
+ *  starts the camera
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+static int tuneserver_start_cam(mm_camera_lib_handle *lib_handle)
+{
+  int result = 0;
+
+  result = mm_camera_lib_start_stream(lib_handle);
+  if (result < 0) {
+    printf("%s: Camera start failed\n", __func__);
+    goto error1;
+  }
+  return result;
+error1:
+  mm_camera_lib_close(lib_handle);
+  return result;
+}
+#endif
+
+/** tuneserver_stop_cam
+ *    @lib_handle: the camera handle object
+ *
+ *  stops the camera
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+int tuneserver_stop_cam(mm_camera_lib_handle *lib_handle)
+{
+  int result = 0;
+
+  result = mm_camera_lib_stop_stream(lib_handle);
+  if (result < 0) {
+    printf("%s: Camera stop failed\n", __func__);
+  }
+//  result = mm_camera_lib_close(lib_handle);
+  return result;
+}
+
+/** tuneserver_open_cam
+ *    @lib_handle: the camera handle object
+ *
+ *  opens the camera
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+#if 1
+int tuneserver_open_cam(mm_camera_lib_handle *lib_handle)
+{
+  int result = 0;
+
+  CDBG("%s  %d\n", __func__, __LINE__);
+  result = mm_camera_load_tuninglibrary(&lib_handle->tsctrl.tuning_params);
+  if (result < 0) {
+    CDBG_ERROR("%s: tuning library open failed\n", __func__);
+  }
+  return result;
+}
+#endif
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c
old mode 100755
new mode 100644
index 149a295..394bbbb
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c
@@ -37,6 +37,7 @@
 #include "mm_qcamera_main_menu.h"
 #include "mm_qcamera_app.h"
 #include "mm_qcamera_dbg.h"
+#include "mm_qcamera_socket.h"
 
 /*===========================================================================
  * Macro
@@ -1690,6 +1691,9 @@ static int submain()
             goto ERROR;
         }
     }
+    /*start the eztune server*/
+    CDBG_HIGH("Starting eztune Server \n");
+    eztune_server_start(&lib_handle);
 
     do {
         print_current_menu (current_menu_id);
@@ -1712,7 +1716,6 @@ static int submain()
                     CDBG_ERROR("%s:mm_camera_lib_start_stream() err=%d\n", __func__, rc);
                     goto ERROR;
                 }
-
                 previewing = 1;
                 break;
 
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
index 10c38b1..7a2e750 100644
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
@@ -129,7 +129,6 @@ static void mm_app_preview_notify_cb(mm_camera_super_buf_t *bufs,
     }
 #endif
     if (pme->user_preview_cb) {
-        printf("%s call back %d\n", __func__, __LINE__);
         CDBG_ERROR("[DBG] %s, user defined own preview cb. calling it...", __func__);
         pme->user_preview_cb(frame);
     }
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c
new file mode 100644
index 0000000..ae5c729
--- /dev/null
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c
@@ -0,0 +1,862 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "mm_qcamera_socket.h"
+#include "mm_qcamera_commands.h"
+#include "mm_qcamera_dbg.h"
+
+#define IP_ADDR                  "127.0.0.1"
+#define TUNING_CHROMATIX_PORT     55555
+#define TUNING_PREVIEW_PORT       55556
+
+#define CURRENT_COMMAND_ACK_SUCCESS 1
+#define CURRENT_COMMAND_ACK_FAILURE 2
+
+pthread_t eztune_thread_id;
+
+static int tuneserver_send_command_rsp(tuningserver_t *tsctrl,
+  char *send_buf, uint32_t send_len)
+{
+  int rc;
+
+  /* send ack back to client upon req */
+  if (send_len <= 0) {
+    ALOGE("%s:Invalid send len \n", __func__);
+    return -1;
+  }
+  if (send_buf == NULL) {
+    ALOGE("%s:Invalid send buf \n", __func__);
+    return -1;
+  }
+
+  rc = send(tsctrl->clientsocket_id, send_buf, send_len, 0);
+  if (rc < 0) {
+    ALOGE("%s:RSP send returns error %s\n", __func__, strerror(errno));
+  } else {
+    rc = 0;
+  }
+
+  if (send_buf != NULL) {
+    free(send_buf);
+    send_buf = NULL;
+  }
+  return rc;
+}
+
+static void release_eztune_prevcmd_rsp(eztune_prevcmd_rsp *pHead)
+{
+  if (pHead != NULL ) {
+    release_eztune_prevcmd_rsp((eztune_prevcmd_rsp *)pHead->next);
+    free(pHead);
+  }
+}
+
+static int tuneserver_ack(uint16_t a, uint32_t b, tuningserver_t *tsctrl)
+{
+  int rc;
+  char ack_1[6];
+  /*Ack the command here*/
+  memcpy(ack_1, &a, 2);
+  memcpy(ack_1+2, &b, 4);
+  /* send echo back to client upon accept */
+  rc = send(tsctrl->clientsocket_id, &ack_1, sizeof(ack_1), 0);
+  if (rc < 0) {
+    ALOGE("%s: eztune_server_run: send returns error %s\n", __func__,
+      strerror(errno));
+    return rc;
+  } else if (rc < (int32_t)sizeof(ack_1)) {
+    /*Shouldn't hit this for packets <1K; need to re-send if we do*/
+  }
+  return 0;
+}
+
+static int tuneserver_send_command_ack( uint8_t ack, tuningserver_t *tsctrl)
+{
+  int rc;
+  /* send ack back to client upon req */
+  rc = send(tsctrl->clientsocket_id, &ack, sizeof(ack), 0);
+  if (rc < 0) {
+    ALOGE("%s:ACK send returns error %s\n", __func__, strerror(errno));
+    return rc;
+  }
+  return 0;
+}
+
+/** tuneserver_process_command
+ *    @tsctrl: the server control object
+ *
+ *  Processes the command that the client sent
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+static int32_t tuneserver_process_command(tuningserver_t *tsctrl,
+  char *send_buf, uint32_t send_len)
+{
+  tuneserver_protocol_t *p = tsctrl->proto;
+  int result = 0;
+
+  CDBG("%s: Current command is %d\n", __func__, p->current_cmd);
+  switch (p->current_cmd) {
+  case TUNESERVER_GET_LIST:
+    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
+      ALOGE("%s: Ack Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    result = tuneserver_process_get_list_cmd(tsctrl, p->recv_buf,
+      send_buf, send_len);
+    if (result < 0) {
+      ALOGE("%s: RSP processing Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    if(tuneserver_send_command_rsp(tsctrl, send_buf, send_len)) {
+      ALOGE("%s: RSP Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    break;
+
+  case TUNESERVER_GET_PARMS:
+    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
+      ALOGE("%s: Ack Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    result = tuneserver_process_get_params_cmd(tsctrl, p->recv_buf,
+      send_buf, send_len);
+    if (result < 0) {
+      ALOGE("%s: RSP processing Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    if(tuneserver_send_command_rsp(tsctrl, send_buf, send_len)) {
+      ALOGE("%s: RSP Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    break;
+
+  case TUNESERVER_SET_PARMS:
+    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
+      ALOGE("%s: Ack Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    result = tuneserver_process_set_params_cmd(tsctrl, p->recv_buf,
+      send_buf, send_len);
+    if (result < 0) {
+      ALOGE("%s: RSP processing Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    if(tuneserver_send_command_rsp(tsctrl, send_buf, send_len)) {
+      ALOGE("%s: RSP Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    break;
+
+  case TUNESERVER_MISC_CMDS: {
+    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
+      ALOGE("%s: Ack Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    result = tuneserver_process_misc_cmd(tsctrl, p->recv_buf,
+      send_buf, send_len);
+    if (result < 0) {
+      ALOGE("%s: RSP processing Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    if(tuneserver_send_command_rsp(tsctrl, send_buf, send_len)) {
+      ALOGE("%s: RSP Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    break;
+  }
+
+  default:
+    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
+      ALOGE("%s: Ack Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    ALOGE("%s: p->current_cmd: default\n", __func__);
+    result = -1;
+    break;
+  }
+
+  return result;
+}
+
+/** tuneserver_process_client_message
+ *    @recv_buffer: received message from the client
+ *    @tsctrl: the server control object
+ *
+ *  Processes the message from client and prepares for next
+ *  message.
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+static int32_t tuneserver_process_client_message(void *recv_buffer,
+  tuningserver_t *tsctrl)
+{
+  int rc = 0;
+  tuneserver_protocol_t *p = tsctrl->proto;
+
+  switch (tsctrl->proto->next_recv_code) {
+  case TUNESERVER_RECV_COMMAND:
+    p->current_cmd = *(uint16_t *)recv_buffer;
+    p->next_recv_code = TUNESERVER_RECV_PAYLOAD_SIZE;
+    p->next_recv_len = sizeof(uint32_t);
+    break;
+
+  case TUNESERVER_RECV_PAYLOAD_SIZE:
+    p->next_recv_code = TUNESERVER_RECV_PAYLOAD;
+    p->next_recv_len = *(uint32_t *)recv_buffer;
+    p->recv_len = p->next_recv_len;
+    if (p->next_recv_len > TUNESERVER_MAX_RECV)
+      return -1;
+    if (p->next_recv_len == 0) {
+      p->next_recv_code = TUNESERVER_RECV_RESPONSE;
+      p->next_recv_len = sizeof(uint32_t);
+    }
+    break;
+
+  case TUNESERVER_RECV_PAYLOAD:
+    p->recv_buf = malloc(p->next_recv_len);
+    if (!p->recv_buf) {
+      ALOGE("%s:Error allocating memory for recv_buf %s\n", __func__,
+        strerror(errno));
+      return -1;
+    }
+    memcpy(p->recv_buf, recv_buffer, p->next_recv_len);
+    p->next_recv_code = TUNESERVER_RECV_RESPONSE;
+    p->next_recv_len = sizeof(uint32_t);
+    /*Process current command at this point*/
+    break;
+
+  case TUNESERVER_RECV_RESPONSE:
+    p->next_recv_code = TUNESERVER_RECV_COMMAND;
+    p->next_recv_len = 2;
+    p->send_len = *(uint32_t *)recv_buffer;
+    p->send_buf =  (char *)calloc(p->send_len, sizeof(char *));
+    if (!p->send_buf) {
+      ALOGE("%s:Error allocating memory for send_buf %s\n", __func__,
+        strerror(errno));
+      return -1;
+    }
+    rc = tuneserver_process_command(tsctrl, p->send_buf, p->send_len);
+    free(p->recv_buf);
+    p->recv_buf = NULL;
+    p->recv_len = 0;
+    break;
+
+  default:
+    ALOGE("%s: p->next_recv_code: default\n", __func__);
+    rc = -1;
+    break;
+  }
+
+  return rc;
+}
+
+/** tuneserver_ack_onaccept_initprotocol
+ *    @tsctrl: the server control object
+ *
+ *  Acks a connection from the cient and sets up the
+ *  protocol object to start receiving commands.
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+static int32_t tuneserver_ack_onaccept_initprotocol(tuningserver_t *tsctrl)
+{
+  int32_t rc = 0;
+  uint32_t ack_status;
+
+  ALOGE("%s starts\n", __func__);
+/*
+  if(tsctrl->camera_running) {
+    ack_status = 1;
+  } else {
+    ack_status = 2;
+  }
+*/
+  ack_status = 1;
+
+  rc = tuneserver_ack(1, ack_status, tsctrl);
+
+  tsctrl->proto = malloc(sizeof(tuneserver_protocol_t));
+  if (!tsctrl->proto) {
+    ALOGE("%s: malloc returns NULL with error %s\n", __func__, strerror(errno));
+    return -1;
+  }
+
+  tsctrl->proto->current_cmd    = 0xFFFF;
+  tsctrl->proto->next_recv_code = TUNESERVER_RECV_COMMAND;
+  tsctrl->proto->next_recv_len  = 2;
+  tsctrl->proto->recv_buf       = NULL;
+  tsctrl->proto->send_buf       = NULL;
+
+  CDBG("%s end\n", __func__);
+
+  return rc;
+}
+
+/** tuneserver_check_status
+ *    @tsctrl: the server control object
+ *
+ *  Checks if camera is running and stops it.
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+#if 0
+static void tuneserver_check_status(tuningserver_t *tsctrl)
+{
+  if (tsctrl->camera_running == 1) {
+    /*TODO: Stop camera here*/
+    tuneserver_stop_cam(&tsctrl->lib_handle);
+  }
+  tsctrl->camera_running = 0;
+
+  tuneserver_close_cam(&tsctrl->lib_handle);
+}
+#endif
+
+static int prevserver_send_command_rsp(tuningserver_t *tsctrl,
+  char *send_buf, uint32_t send_len)
+{
+  int rc;
+
+  /* send ack back to client upon req */
+  if (send_len <= 0) {
+    ALOGE("%s:Invalid send len \n", __func__);
+    return -1;
+  }
+  if (send_buf == NULL) {
+    ALOGE("%s:Invalid send buf \n", __func__);
+    return -1;
+  }
+
+  rc = send(tsctrl->pr_clientsocket_id, send_buf, send_len, 0);
+  if (rc < 0) {
+    ALOGE("%s:RSP send returns error %s\n", __func__, strerror(errno));
+  } else {
+    rc = 0;
+  }
+  if (send_buf != NULL) {
+    free(send_buf);
+    send_buf = NULL;
+  }
+  return rc;
+}
+
+static void prevserver_init_protocol(tuningserver_t *tsctrl)
+{
+  tsctrl->pr_proto = malloc(sizeof(prserver_protocol_t));
+  if (!tsctrl->pr_proto) {
+    ALOGE("%s: malloc returns NULL with error %s\n",
+     __func__, strerror(errno));
+    return;
+  }
+
+  tsctrl->pr_proto->current_cmd    = 0xFFFF;
+  tsctrl->pr_proto->next_recv_code = TUNE_PREV_RECV_COMMAND;
+  tsctrl->pr_proto->next_recv_len  = 2;
+}
+
+static int32_t prevserver_process_command(
+  tuningserver_t *tsctrl, char **send_buf, uint32_t *send_len)
+{
+  prserver_protocol_t *p = tsctrl->pr_proto;
+  int result = 0;
+  eztune_prevcmd_rsp *rsp_ptr=NULL, *rspn_ptr=NULL, *head_ptr=NULL;
+
+  CDBG("%s: Current command is %d\n", __func__, p->current_cmd);
+  switch (p->current_cmd) {
+  case TUNE_PREV_GET_INFO:
+    result = tuneserver_preview_getinfo(tsctrl, send_buf, send_len);
+    if (result < 0) {
+      ALOGE("%s: RSP processing Failed for cmd %d\n", __func__,
+        p->current_cmd);
+      return -1;
+    }
+    rsp_ptr = (eztune_prevcmd_rsp *)*send_buf;
+    if ((!rsp_ptr) || (!rsp_ptr->send_buf)) {
+      ALOGE("%s: RSP ptr is NULL %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    if (prevserver_send_command_rsp(tsctrl,
+      rsp_ptr->send_buf, rsp_ptr->send_len)) {
+      ALOGE("%s: RSP Failed for TUNE_PREV_GET_INFO ver cmd %d\n", __func__,
+        p->current_cmd);
+      return -1;
+    }
+    rspn_ptr = (eztune_prevcmd_rsp *)rsp_ptr->next;
+    if ((!rspn_ptr) || (!rspn_ptr->send_buf)) {
+      ALOGE("%s: RSP1 ptr is NULL %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    if (prevserver_send_command_rsp(tsctrl,
+        rspn_ptr->send_buf, rspn_ptr->send_len)) {
+      ALOGE("%s: RSP Failed for TUNE_PREV_GET_INFO caps cmd %d\n", __func__,
+        p->current_cmd);
+      return -1;
+    }
+    free(rspn_ptr);
+    free(rsp_ptr);
+    break;
+
+  case TUNE_PREV_CH_CNK_SIZE:
+    result = tuneserver_preview_getchunksize(tsctrl, send_buf, send_len);
+    if (result < 0) {
+      ALOGE("%s: RSP processing Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    if (prevserver_send_command_rsp(tsctrl, *send_buf, *send_len)) {
+      ALOGE("%s: RSP Failed for TUNE_PREV_CH_CNK_SIZE cmd %d\n", __func__,
+        p->current_cmd);
+      return -1;
+    }
+    break;
+
+  case TUNE_PREV_GET_PREV_FRAME:
+    result = tuneserver_preview_getframe(tsctrl, send_buf, send_len);
+    if (result < 0) {
+      ALOGE("%s: RSP processing Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    rsp_ptr = (eztune_prevcmd_rsp *)*send_buf;
+    if ((!rsp_ptr) || (!rsp_ptr->send_buf)) {
+      ALOGE("%s: RSP ptr is NULL %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    head_ptr = rsp_ptr;
+
+    while (rsp_ptr != NULL) {
+      if ((!rsp_ptr) || (!rsp_ptr->send_buf)) {
+        ALOGE("%s: RSP ptr is NULL %d\n", __func__, p->current_cmd);
+        return -1;
+      }
+      if (prevserver_send_command_rsp(tsctrl,
+        rsp_ptr->send_buf, rsp_ptr->send_len)) {
+        ALOGE("%s: RSP Failed for TUNE_PREV_GET_INFO ver cmd %d\n", __func__,
+          p->current_cmd);
+        return -1;
+      }
+      rsp_ptr = (eztune_prevcmd_rsp *)rsp_ptr->next;
+    }
+    release_eztune_prevcmd_rsp(head_ptr);
+    break;
+
+  case TUNE_PREV_GET_JPG_SNAP:
+  case TUNE_PREV_GET_RAW_SNAP:
+  case TUNE_PREV_GET_RAW_PREV:
+    result = tuneserver_preview_unsupported(tsctrl, send_buf, send_len);
+    if (result < 0) {
+       ALOGE("%s:RSP processing Failed for cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    if (prevserver_send_command_rsp(tsctrl, *send_buf, *send_len)) {
+      ALOGE("%s:RSP Failed for UNSUPPORTED cmd %d\n", __func__, p->current_cmd);
+      return -1;
+    }
+    break;
+
+  default:
+    ALOGE("%s: p->current_cmd: default\n", __func__);
+    result = -1;
+    break;
+  }
+
+  return result;
+}
+
+/** previewserver_process_client_message
+ *    @recv_buffer: received message from the client
+ *    @tsctrl: the server control object
+ *
+ *  Processes the message from client and prepares for next
+ *  message.
+ *
+ *  Return: >=0 on success, -1 on failure.
+ **/
+static int32_t prevserver_process_client_message(void *recv_buffer,
+  tuningserver_t *tsctrl)
+{
+  int rc = 0;
+  prserver_protocol_t *p = tsctrl->pr_proto;
+
+  switch (p->next_recv_code) {
+  case TUNE_PREV_RECV_COMMAND:
+    CDBG("%s  %d\n", __func__, __LINE__);
+    p->current_cmd = *(uint16_t *)recv_buffer;
+    if(p->current_cmd != TUNE_PREV_CH_CNK_SIZE) {
+      rc = prevserver_process_command(tsctrl,
+        &p->send_buf, (uint32_t *)&p->send_len);
+      break;
+    }
+    p->next_recv_code = TUNE_PREV_RECV_NEWCNKSIZE;
+    p->next_recv_len = sizeof(uint32_t);
+    CDBG("%s TUNE_PREV_COMMAND X\n", __func__);
+    break;
+  case TUNE_PREV_RECV_NEWCNKSIZE:
+    CDBG("%s  %d\n", __func__, __LINE__);
+    p->new_cnk_size = *(uint32_t *)recv_buffer;
+    p->next_recv_code = TUNE_PREV_RECV_COMMAND;
+    p->next_recv_len  = 2;
+    rc = prevserver_process_command(tsctrl,
+      &p->send_buf, (uint32_t *)&p->send_len);
+    break;
+  default:
+    ALOGE("%s prev_proc->next_recv_code: default\n", __func__);
+    rc = -1;
+    break;
+  }
+
+  return rc;
+}
+
+/** tunning_server_socket_listen
+ *    @ip_addr: the ip addr to listen
+ *    @port: the port to listen
+ *
+ *  Setup a listen socket for eztune.
+ *
+ *  Return: >0 on success, <=0 on failure.
+ **/
+int tunning_server_socket_listen(const char* ip_addr, uint16_t port)
+{
+  int sock_fd = -1;
+  struct sockaddr_in server_addr;
+  int result;
+  int option;
+  int socket_flag;
+
+  memset(&server_addr, 0, sizeof(server_addr));
+  server_addr.sin_family = AF_INET;
+  server_addr.sin_port= htons(port);
+  server_addr.sin_addr.s_addr = inet_addr(ip_addr);
+
+  if (server_addr.sin_addr.s_addr == INADDR_NONE) {
+    ALOGE("[ERR] %s invalid address.\n", __func__);
+    return -1;
+  }
+
+  /* Create an AF_INET stream socket to receive incoming connection ON */
+  sock_fd = socket(AF_INET, SOCK_STREAM, 0);
+  if (sock_fd < 0) {
+    ALOGE("[ERR] %s socket failed\n", __func__);
+    return sock_fd;
+  }
+
+  // set listen socket to non-block, but why??
+  socket_flag = fcntl(sock_fd, F_GETFL, 0);
+  fcntl(sock_fd, F_SETFL, socket_flag | O_NONBLOCK);
+
+  /* reuse in case it is in timeout */
+  option = 1;
+  result = setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR,
+    &option, sizeof(option));
+
+  if (result < 0) {
+    ALOGE("eztune setsockopt failed");
+    close(sock_fd);
+    sock_fd = -1;
+    return sock_fd;
+  }
+
+  result = bind(sock_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));
+  if (result < 0) {
+    ALOGE("eztune socket bind failed");
+    close(sock_fd);
+    sock_fd = -1;
+    return sock_fd;
+  }
+
+  result = listen(sock_fd, 1);
+  if (result < 0) {
+    ALOGE("eztune socket listen failed");
+    close(sock_fd);
+    sock_fd = -1;
+    return sock_fd;
+  }
+
+  CDBG_HIGH("%s. sock_fd: %d, listen at port: %d\n", __func__, sock_fd, port);
+
+  return sock_fd;
+}
+
+/** main
+ *
+ *  Creates the server, and starts waiting for
+ *  connections/messages from a prospective
+ *  client
+ *
+ **/
+void *eztune_proc(void *data)
+{
+  int server_socket = -1, client_socket = -1;
+  int prev_server_socket = -1, prev_client_socket = -1;
+
+  struct sockaddr_in addr_client_inet;
+  socklen_t addr_client_len = sizeof(struct sockaddr_in);
+  int result;
+  fd_set tsfds;
+  int num_fds = 0;
+  int recv_bytes;
+  char buf[TUNESERVER_MAX_RECV];
+
+  mm_camera_lib_handle *lib_handle = (mm_camera_lib_handle *)data;
+
+  ALOGE(">>> Starting tune server <<< \n");
+
+  // for eztune chromatix params
+  server_socket = tunning_server_socket_listen(IP_ADDR, TUNING_CHROMATIX_PORT);
+  if (server_socket <= 0) {
+    ALOGE("[ERR] fail to setup listen socket for eztune chromatix parms...");
+    return NULL;
+  }
+  prev_server_socket = tunning_server_socket_listen(IP_ADDR, TUNING_PREVIEW_PORT);
+  if (prev_server_socket <= 0) {
+    ALOGE("[ERR] fail to setup listen socket for eztune preview...\n");
+    return NULL;
+  }
+  num_fds = TUNESERVER_MAX(server_socket, prev_server_socket);
+  CDBG_HIGH("num_fds = %d\n", num_fds);
+
+  do {
+    FD_ZERO(&tsfds);
+    FD_SET(server_socket, &tsfds);
+    FD_SET(prev_server_socket, &tsfds);
+    if (client_socket > 0) {
+      FD_SET(client_socket, &tsfds);
+    }
+    if (prev_client_socket > 0) {
+      FD_SET( prev_client_socket, &tsfds);
+    }
+
+    /* no timeout */
+    result = select(num_fds + 1, &tsfds, NULL, NULL, NULL);
+    if (result < 0) {
+      ALOGE("[ERR] select failed: %s\n", strerror(errno));
+      continue;
+    }
+
+    /*
+     ** (1) CHROMATIX SERVER
+     */
+    if (FD_ISSET(server_socket, &tsfds)) {
+      CDBG("Receiving New client connection\n");
+
+      client_socket = accept(server_socket,
+        (struct sockaddr *)&addr_client_inet, &addr_client_len);
+      if (client_socket == -1) {
+        ALOGE("accept failed %s", strerror(errno));
+        continue;
+      }
+
+      ALOGE("accept a new connect on 55555, sd(%d)\n", client_socket);
+      num_fds = TUNESERVER_MAX(num_fds, client_socket);
+
+      // open camera and get handle - this is needed to
+      // be able to set parameters without starting
+      // preview stream
+      /*if (!tsctrl.camera_running) {
+        result = tuneserver_open_cam(&tsctrl.lib_handle, &tsctrl);
+        if(result) {
+          printf("\n Camera Open Fail !!! \n");
+          close(server_socket);
+          return EXIT_FAILURE;
+        }
+      }*/
+      result = tuneserver_open_cam(lib_handle);
+      if(result) {
+        ALOGE("\n Tuning Library open failed!!!\n");
+        close(server_socket);
+        return NULL;
+      }
+      lib_handle->tsctrl.clientsocket_id = client_socket;
+      if (tuneserver_ack_onaccept_initprotocol(&lib_handle->tsctrl) < 0) {
+        ALOGE("%s: Error while acking\n", __func__);
+        close(client_socket);
+        continue;
+      }
+      tuneserver_initialize_tuningp(lib_handle, client_socket,
+        lib_handle->tsctrl.proto->send_buf, lib_handle->tsctrl.proto->send_len);
+    }
+
+    if (FD_ISSET(client_socket, &tsfds)) {
+      if (lib_handle->tsctrl.proto == NULL) {
+        ALOGE("%s: Cannot receive msg without connect\n", __func__);
+        continue;
+      }
+
+      /*Receive message and process it*/
+      recv_bytes = recv(client_socket, (void *)buf,
+        lib_handle->tsctrl.proto->next_recv_len, 0);
+      CDBG("Receive %d bytes \n", recv_bytes);
+
+      if (recv_bytes == -1) {
+        ALOGE("%s: Receive failed with error %s\n", __func__, strerror(errno));
+        //tuneserver_check_status(&tsctrl);
+        continue;
+      } else if (recv_bytes == 0) {
+        ALOGE("%s %d: connection has been terminated\n", __func__, __LINE__);
+
+        tuneserver_deinitialize_tuningp(&lib_handle->tsctrl, client_socket,
+          lib_handle->tsctrl.proto->send_buf,
+          lib_handle->tsctrl.proto->send_len);
+        free(lib_handle->tsctrl.proto);
+        lib_handle->tsctrl.proto = NULL;
+
+        close(client_socket);
+        client_socket = 0;
+        //tuneserver_check_status(&tsctrl);
+      } else {
+        CDBG("%s: Processing socket command\n", __func__);
+
+        result = tuneserver_process_client_message(buf, &lib_handle->tsctrl);
+
+        if (result < 0) {
+          ALOGE("%s %d Protocol violated\n", __func__, __LINE__);
+
+          free(lib_handle->tsctrl.proto);
+          lib_handle->tsctrl.proto = NULL;
+
+          close(client_socket);
+          client_socket = 0;
+          //tuneserver_check_status(&tsctrl);
+          continue;
+        }
+      }
+    }
+
+    /*
+     ** (2) PREVIEW SERVER
+     */
+    if (FD_ISSET(prev_server_socket, &tsfds)) {
+      CDBG("Receiving New Preview client connection\n");
+
+      prev_client_socket = accept(prev_server_socket,
+        (struct sockaddr *)&addr_client_inet, &addr_client_len);
+      if (prev_client_socket == -1) {
+        ALOGE("accept failed %s", strerror(errno));
+        continue;
+      }
+
+      lib_handle->tsctrl.pr_clientsocket_id = prev_client_socket;
+
+      CDBG("Accepted a new connection, fd(%d)\n", prev_client_socket);
+      num_fds = TUNESERVER_MAX(num_fds, prev_client_socket);
+
+      // start camera
+      /*if (!tsctrl.camera_running) {
+        result = 0;
+        result = tuneserver_open_cam(&tsctrl.lib_handle, &tsctrl);
+        if(result) {
+          printf("\n Camera Open Fail !!! \n");
+          return EXIT_FAILURE;
+        }
+      }*/
+      cam_dimension_t dim;
+      dim.width = lib_handle->test_obj.buffer_width;
+      dim.height = lib_handle->test_obj.buffer_height;
+
+      CDBG("preview dimension info: w(%d), h(%d)\n", dim.width, dim.height);
+      // we have to make sure that camera is running, before init connection,
+      // because we need to know the frame size for allocating the memory.
+      prevserver_init_protocol(&lib_handle->tsctrl);
+
+      result = tuneserver_initialize_prevtuningp(lib_handle, prev_client_socket,
+        dim, (char **)&lib_handle->tsctrl.proto->send_buf,
+        &lib_handle->tsctrl.proto->send_len);
+      if (result < 0) {
+        ALOGE("tuneserver_initialize_prevtuningp error!");
+        close(prev_client_socket);
+        prev_client_socket = 0;
+      }
+    }
+
+    if (FD_ISSET(prev_client_socket, &tsfds)) {
+      recv_bytes = recv(prev_client_socket, (void *)buf,
+        lib_handle->tsctrl.pr_proto->next_recv_len, 0);
+
+      CDBG("%s prev_client_socket=%d\n", __func__, prev_client_socket);
+      CDBG("%s next_recv_len=%d\n", __func__, *(uint16_t *)buf);
+
+      if (recv_bytes <= 0) {
+        if (recv_bytes == 0) {
+          ALOGE("client close the connection.\n");
+        } else {
+          ALOGE("receive error: %s\n", strerror(errno));
+        }
+
+        //tuneserver_check_status(&tsctrl);
+        // if recv error, we should close the connection, free the proto data,
+        // AND wait for a new connecton..
+        // close_connection();
+        // stop_camera()
+        // cleanup_proto_data();
+        tuneserver_deinitialize_prevtuningp(&lib_handle->tsctrl,
+          (char **)&lib_handle->tsctrl.proto->send_buf,
+          &lib_handle->tsctrl.proto->send_len);
+        close(prev_client_socket);
+        prev_client_socket = 0;
+      } else {
+        result = prevserver_process_client_message((void *)buf,
+          &lib_handle->tsctrl);
+        if (result < 0) {
+          ALOGE("%s %d Protocol violated\n", __func__, __LINE__);
+
+          //free(tsctrl->preivew_proto);
+          //free(tsctrl);
+          //max_fd = ezt_parms_listen_sd + 1;
+          tuneserver_deinitialize_prevtuningp(&lib_handle->tsctrl,
+            (char **)&lib_handle->tsctrl.proto->send_buf,
+            &lib_handle->tsctrl.proto->send_len);
+          close(prev_client_socket);
+          prev_client_socket = 0;
+          //tuneserver_check_status(&tsctrl);
+        }
+        //sleep(1);
+      }
+    }
+  } while (1);
+
+  if (server_socket > 0) {
+    close(server_socket);
+  }
+  if (client_socket > 0) {
+    close(client_socket);
+  }
+  if (prev_server_socket > 0) {
+    close(prev_server_socket);
+  }
+  if (prev_client_socket > 0) {
+    close(prev_client_socket);
+  }
+
+  return EXIT_SUCCESS;
+}
+
+int eztune_server_start (void *lib_handle)
+{
+  return pthread_create(&eztune_thread_id, NULL,  eztune_proc, lib_handle);
+}
+
-- 
1.8.3.1

