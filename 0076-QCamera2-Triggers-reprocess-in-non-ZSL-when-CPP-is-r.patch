From 27495930a9becb2dd78f53e5055a6f32e1ddfb87 Mon Sep 17 00:00:00 2001
From: Emilian Peev <epeevs@codeaurora.org>
Date: Mon, 11 Nov 2013 06:12:18 -0800
Subject: [PATCH 076/176] QCamera2: Triggers reprocess in non-ZSL when CPP is
 required

- Usually reprocessing will be done only in few cases
  during non-ZSL. This change introduces a more
  general feature 'CAM_QCOM_FEATURE_CPP' instead of
  'CAM_QCOM_FEATURE_ROTATION', which can trigger
  reprocessing if required by backend.

Change-Id: I49b04af5b233a4ef5bef9731137e8d0fcccdb2bc
CRs-Fixed: 571775
---
 QCamera2/HAL/QCamera2HWI.cpp                       | 66 +++++++++++-----------
 QCamera2/HAL/QCameraChannel.cpp                    | 14 +++--
 QCamera2/HAL/QCameraParameters.cpp                 |  6 +-
 QCamera2/HAL/QCameraStream.cpp                     |  2 +-
 QCamera2/stack/common/cam_types.h                  |  2 +-
 .../mm-camera-interface/src/mm_camera_stream.c     |  2 +-
 6 files changed, 49 insertions(+), 43 deletions(-)

diff --git a/QCamera2/HAL/QCamera2HWI.cpp b/QCamera2/HAL/QCamera2HWI.cpp
index 86158ad..b128db4 100644
--- a/QCamera2/HAL/QCamera2HWI.cpp
+++ b/QCamera2/HAL/QCamera2HWI.cpp
@@ -1662,7 +1662,6 @@ QCameraHeapMemory *QCamera2HardwareInterface::allocateStreamInfoBuf(
     cam_stream_type_t stream_type)
 {
     int rc = NO_ERROR;
-    const char *effect;
 
     QCameraHeapMemory *streamInfoBuf = new QCameraHeapMemory(QCAMERA_ION_USE_CACHE);
     if (!streamInfoBuf) {
@@ -1732,24 +1731,6 @@ QCameraHeapMemory *QCamera2HardwareInterface::allocateStreamInfoBuf(
         }
     }
 
-    if (!isZSLMode()) {
-        if (gCamCapability[mCameraId]->min_required_pp_mask & CAM_QCOM_FEATURE_SHARPNESS) {
-            streamInfo->pp_config.feature_mask |= CAM_QCOM_FEATURE_SHARPNESS;
-            streamInfo->pp_config.sharpness = mParameters.getInt(QCameraParameters::KEY_QC_SHARPNESS);
-        }
-
-        if (gCamCapability[mCameraId]->min_required_pp_mask & CAM_QCOM_FEATURE_EFFECT) {
-            streamInfo->pp_config.feature_mask |= CAM_QCOM_FEATURE_EFFECT;
-            effect = mParameters.get(CameraParameters::KEY_EFFECT);
-            streamInfo->pp_config.effect = getEffectValue(effect);
-        }
-        if (mParameters.isWNREnabled() && (mParameters.getRecordingHintValue() == false)) {
-            streamInfo->pp_config.feature_mask |= CAM_QCOM_FEATURE_DENOISE2D;
-            streamInfo->pp_config.denoise2d.denoise_enable = 1;
-            streamInfo->pp_config.denoise2d.process_plates = mParameters.getWaveletDenoiseProcessPlate();
-        }
-    }
-
     return streamInfoBuf;
 }
 
@@ -3912,12 +3893,11 @@ QCameraReprocessChannel *QCamera2HardwareInterface::addOnlineReprocChannel(
     }
 
     ALOGD("%s: Before pproc config check, ret = %x", __func__, gCamCapability[mCameraId]->min_required_pp_mask);
-
     // pp feature config
     cam_pp_feature_config_t pp_config;
+    uint32_t required_mask = gCamCapability[mCameraId]->min_required_pp_mask;
     memset(&pp_config, 0, sizeof(cam_pp_feature_config_t));
-
-    if (mParameters.isZSLMode()) {
+    if (mParameters.isZSLMode() || (required_mask & CAM_QCOM_FEATURE_CPP)) {
         if (gCamCapability[mCameraId]->min_required_pp_mask & CAM_QCOM_FEATURE_EFFECT) {
             pp_config.feature_mask |= CAM_QCOM_FEATURE_EFFECT;
             effect = mParameters.get(CameraParameters::KEY_EFFECT);
@@ -3933,6 +3913,11 @@ QCameraReprocessChannel *QCamera2HardwareInterface::addOnlineReprocChannel(
             pp_config.denoise2d.denoise_enable = 1;
             pp_config.denoise2d.process_plates = mParameters.getWaveletDenoiseProcessPlate();
         }
+
+        if (required_mask & CAM_QCOM_FEATURE_CPP) {
+            pp_config.feature_mask |= CAM_QCOM_FEATURE_CPP;
+        }
+
     }
 
     if (isCACEnabled()) {
@@ -3940,7 +3925,7 @@ QCameraReprocessChannel *QCamera2HardwareInterface::addOnlineReprocChannel(
     }
 
     if (needRotationReprocess()) {
-        pp_config.feature_mask |= CAM_QCOM_FEATURE_ROTATION;
+        pp_config.feature_mask |= CAM_QCOM_FEATURE_CPP;
         int rotation = getJpegRotation();
         if (rotation == 0) {
             pp_config.rotation = ROTATE_0;
@@ -4908,8 +4893,13 @@ bool QCamera2HardwareInterface::needReprocess()
         return true;
     }
 
-    if ((gCamCapability[mCameraId]->qcom_supported_feature_mask & CAM_QCOM_FEATURE_ROTATION) > 0 &&
-            (getJpegRotation() > 0) &&  (mParameters.getRecordingHintValue() == false)) {
+    uint32_t feature_mask = 0;
+    uint32_t required_mask = 0;
+    feature_mask = gCamCapability[mCameraId]->qcom_supported_feature_mask;
+    required_mask = gCamCapability[mCameraId]->min_required_pp_mask;
+    if (((feature_mask & CAM_QCOM_FEATURE_CPP) > 0) &&
+        (getJpegRotation() > 0) &&
+        (mParameters.getRecordingHintValue() == false)) {
             // current rotation is not zero, and pp has the capability to process rotation
             ALOGD("%s: need to do reprocess for rotation=%d", __func__, getJpegRotation());
             pthread_mutex_unlock(&m_parm_lock);
@@ -4932,6 +4922,12 @@ bool QCamera2HardwareInterface::needReprocess()
             pthread_mutex_unlock(&m_parm_lock);
             return true;
         }
+    } else {
+        if (required_mask & CAM_QCOM_FEATURE_CPP) {
+            ALOGD("%s: Need CPP in non-ZSL mode", __func__);
+            pthread_mutex_unlock(&m_parm_lock);
+            return true;
+        }
     }
 
     if ((gCamCapability[mCameraId]->qcom_supported_feature_mask & CAM_QCOM_FEATURE_SCALE) > 0 &&
@@ -4967,13 +4963,19 @@ bool QCamera2HardwareInterface::needRotationReprocess()
         return false;
     }
 
-        if ((gCamCapability[mCameraId]->qcom_supported_feature_mask & CAM_QCOM_FEATURE_ROTATION) > 0 &&
-            (getJpegRotation() > 0) && (mParameters.getRecordingHintValue() == false)) {
-            // current rotation is not zero, and pp has the capability to process rotation
-            ALOGD("%s: need to do reprocess for rotation=%d", __func__, getJpegRotation());
-            pthread_mutex_unlock(&m_parm_lock);
-            return true;
-        }
+    uint32_t feature_mask = 0;
+    feature_mask = gCamCapability[mCameraId]->qcom_supported_feature_mask;
+    if (((feature_mask & CAM_QCOM_FEATURE_CPP) > 0) &&
+        (getJpegRotation() > 0) &&
+        (mParameters.getRecordingHintValue() == false)) {
+        // current rotation is not zero
+        // and pp has the capability to process rotation
+        ALOGD("%s: need to do reprocess for rotation=%d",
+              __func__,
+              getJpegRotation());
+        pthread_mutex_unlock(&m_parm_lock);
+        return true;
+    }
 
     pthread_mutex_unlock(&m_parm_lock);
     return false;
diff --git a/QCamera2/HAL/QCameraChannel.cpp b/QCamera2/HAL/QCameraChannel.cpp
index 408fb30..0f47b6f 100644
--- a/QCamera2/HAL/QCameraChannel.cpp
+++ b/QCamera2/HAL/QCameraChannel.cpp
@@ -820,7 +820,9 @@ int32_t QCameraReprocessChannel::addReprocStreamsFromSource(QCameraAllocator& al
                 }
             }
 
-            if (streamInfo->reprocess_config.pp_feature_config.feature_mask & CAM_QCOM_FEATURE_ROTATION) {
+            uint32_t mask;
+            mask = streamInfo->reprocess_config.pp_feature_config.feature_mask;
+            if (mask & CAM_QCOM_FEATURE_CPP) {
                 if (streamInfo->reprocess_config.pp_feature_config.rotation == ROTATE_90 ||
                     streamInfo->reprocess_config.pp_feature_config.rotation == ROTATE_270) {
                     // rotated by 90 or 270, need to switch width and height
@@ -830,8 +832,9 @@ int32_t QCameraReprocessChannel::addReprocStreamsFromSource(QCameraAllocator& al
                 }
             }
 
-            if (param.isZSLMode() &&
-                (streamInfo->reprocess_config.online.input_stream_type == CAM_STREAM_TYPE_SNAPSHOT)) {
+            cam_stream_type_t type = CAM_STREAM_TYPE_DEFAULT;
+            type = streamInfo->reprocess_config.online.input_stream_type;
+            if (type == CAM_STREAM_TYPE_SNAPSHOT) {
                 // ZSL mode snapshot need reprocess to do the flip
                 int flipMode =
                     param.getFlipMode(streamInfo->reprocess_config.online.input_stream_type);
@@ -841,11 +844,12 @@ int32_t QCameraReprocessChannel::addReprocStreamsFromSource(QCameraAllocator& al
                 }
             }
 
-            if(streamInfo->reprocess_config.pp_feature_config.feature_mask & CAM_QCOM_FEATURE_SCALE){
+            mask = streamInfo->reprocess_config.pp_feature_config.feature_mask;
+            if (mask & CAM_QCOM_FEATURE_SCALE) {
                 //we only Scale Snapshot frame
                 if(pStream->isTypeOf(CAM_STREAM_TYPE_SNAPSHOT)){
                     //also check whether rotation is needed
-                    if((streamInfo->reprocess_config.pp_feature_config.feature_mask & CAM_QCOM_FEATURE_ROTATION) &&
+                    if((mask & CAM_QCOM_FEATURE_CPP) &&
                        (streamInfo->reprocess_config.pp_feature_config.rotation == ROTATE_90 ||
                         streamInfo->reprocess_config.pp_feature_config.rotation == ROTATE_270)){
                         //need swap
diff --git a/QCamera2/HAL/QCameraParameters.cpp b/QCamera2/HAL/QCameraParameters.cpp
index a072210..7a2a47c 100644
--- a/QCamera2/HAL/QCameraParameters.cpp
+++ b/QCamera2/HAL/QCameraParameters.cpp
@@ -5701,16 +5701,16 @@ int32_t QCameraParameters::getStreamRotation(cam_stream_type_t streamType,
     case CAM_STREAM_TYPE_VIDEO:
            switch(rotationParam) {
             case 90:
-               featureConfig.feature_mask |= CAM_QCOM_FEATURE_ROTATION;
+               featureConfig.feature_mask |= CAM_QCOM_FEATURE_CPP;
                featureConfig.rotation = ROTATE_90;
                swapDim = 1;
                break;
             case 180:
-               featureConfig.feature_mask |= CAM_QCOM_FEATURE_ROTATION;
+               featureConfig.feature_mask |= CAM_QCOM_FEATURE_CPP;
                featureConfig.rotation = ROTATE_180;
                break;
             case 270:
-               featureConfig.feature_mask |= CAM_QCOM_FEATURE_ROTATION;
+               featureConfig.feature_mask |= CAM_QCOM_FEATURE_CPP;
                featureConfig.rotation = ROTATE_270;
                swapDim = 1;
               break;
diff --git a/QCamera2/HAL/QCameraStream.cpp b/QCamera2/HAL/QCameraStream.cpp
index 6148f23..00c7353 100644
--- a/QCamera2/HAL/QCameraStream.cpp
+++ b/QCamera2/HAL/QCameraStream.cpp
@@ -456,7 +456,7 @@ int32_t QCameraStream::calcOffset(cam_stream_info_t *streamInfo)
     int32_t rc = 0;
 
     cam_dimension_t dim = streamInfo->dim;
-    if (streamInfo->pp_config.feature_mask & CAM_QCOM_FEATURE_ROTATION &&
+    if (streamInfo->pp_config.feature_mask & CAM_QCOM_FEATURE_CPP &&
         streamInfo->stream_type != CAM_STREAM_TYPE_VIDEO) {
         if (streamInfo->pp_config.rotation == ROTATE_90 ||
             streamInfo->pp_config.rotation == ROTATE_270) {
diff --git a/QCamera2/stack/common/cam_types.h b/QCamera2/stack/common/cam_types.h
index 8757203..0250088 100644
--- a/QCamera2/stack/common/cam_types.h
+++ b/QCamera2/stack/common/cam_types.h
@@ -1244,7 +1244,7 @@ typedef struct {
 #define CAM_QCOM_FEATURE_FACE_DETECTION (1<<0)
 #define CAM_QCOM_FEATURE_DENOISE2D      (1<<1)
 #define CAM_QCOM_FEATURE_CROP           (1<<2)
-#define CAM_QCOM_FEATURE_ROTATION       (1<<3)
+#define CAM_QCOM_FEATURE_CPP            (1<<3)
 #define CAM_QCOM_FEATURE_FLIP           (1<<4)
 #define CAM_QCOM_FEATURE_HDR            (1<<5)
 #define CAM_QCOM_FEATURE_REGISTER_FACE  (1<<6)
diff --git a/QCamera2/stack/mm-camera-interface/src/mm_camera_stream.c b/QCamera2/stack/mm-camera-interface/src/mm_camera_stream.c
index 8d4fde2..819827c 100644
--- a/QCamera2/stack/mm-camera-interface/src/mm_camera_stream.c
+++ b/QCamera2/stack/mm-camera-interface/src/mm_camera_stream.c
@@ -2655,7 +2655,7 @@ int32_t mm_stream_calc_offset(mm_stream_t *my_obj)
     int32_t rc = 0;
 
     cam_dimension_t dim = my_obj->stream_info->dim;
-    if (my_obj->stream_info->pp_config.feature_mask & CAM_QCOM_FEATURE_ROTATION &&
+    if (my_obj->stream_info->pp_config.feature_mask & CAM_QCOM_FEATURE_CPP &&
         my_obj->stream_info->stream_type != CAM_STREAM_TYPE_VIDEO) {
         if (my_obj->stream_info->pp_config.rotation == ROTATE_90 ||
             my_obj->stream_info->pp_config.rotation == ROTATE_270) {
-- 
1.8.3.1

