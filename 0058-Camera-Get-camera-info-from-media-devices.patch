From d0ebcfdb1909f142a2e391a84d2a0c858cae060a Mon Sep 17 00:00:00 2001
From: Sai Kumar Sanagavarapu <ssanagav@codeaurora.org>
Date: Thu, 14 Nov 2013 18:27:04 +0530
Subject: [PATCH 058/176] Camera: Get camera info from media devices.

Query camera info like back/front facing and mount angle
from media devices (/dev/media) instead of opening video
devices (/dev/video) to avoid launch latencies.

Change-Id: I8e9b14140bb394f700a778546c4bf69778b2d9f8
---
 QCamera2/HAL/QCamera2HWI.cpp                       | 43 ++--------
 QCamera2/HAL/QCamera2HWI.h                         |  2 +-
 QCamera2/stack/common/mm_camera_interface.h        |  2 +-
 QCamera2/stack/mm-camera-interface/inc/mm_camera.h |  3 +-
 .../mm-camera-interface/src/mm_camera_interface.c  | 94 +++++++++++++++++++++-
 5 files changed, 103 insertions(+), 41 deletions(-)

diff --git a/QCamera2/HAL/QCamera2HWI.cpp b/QCamera2/HAL/QCamera2HWI.cpp
index e68ece9..3f7118d 100644
--- a/QCamera2/HAL/QCamera2HWI.cpp
+++ b/QCamera2/HAL/QCamera2HWI.cpp
@@ -1076,6 +1076,8 @@ int QCamera2HardwareInterface::openCamera()
         return UNKNOWN_ERROR;
     }
 
+    initCapabilities(mCameraId,mCameraHandle);
+
     mCameraHandle->ops->register_event_notify(mCameraHandle->camera_handle,
                                               camEvtHandle,
                                               (void *) this);
@@ -1246,19 +1248,11 @@ int QCamera2HardwareInterface::closeCamera()
  *              NO_ERROR  -- success
  *              none-zero failure code
  *==========================================================================*/
-int QCamera2HardwareInterface::initCapabilities(int cameraId)
+int QCamera2HardwareInterface::initCapabilities(int cameraId,mm_camera_vtbl_t *cameraHandle)
 {
     int rc = NO_ERROR;
-    mm_camera_vtbl_t *cameraHandle = NULL;
     QCameraHeapMemory *capabilityHeap = NULL;
 
-    cameraHandle = camera_open(cameraId);
-    if (!cameraHandle) {
-        ALOGE("%s: camera_open failed", __func__);
-        rc = UNKNOWN_ERROR;
-        goto open_failed;
-    }
-
     /* Allocate memory for capability buffer */
     capabilityHeap = new QCameraHeapMemory(QCAMERA_ION_USE_CACHE);
     rc = capabilityHeap->allocate(1, sizeof(cam_capability_t));
@@ -1310,9 +1304,6 @@ map_failed:
     capabilityHeap->deallocate();
     delete capabilityHeap;
 allocate_failed:
-    cameraHandle->ops->close_camera(cameraHandle->camera_handle);
-    cameraHandle = NULL;
-open_failed:
     return rc;
 }
 
@@ -1333,32 +1324,10 @@ int QCamera2HardwareInterface::getCapabilities(int cameraId,
                                     struct camera_info *info)
 {
     int rc = NO_ERROR;
-
+    struct  camera_info *p_info;
     pthread_mutex_lock(&g_camlock);
-    if (NULL == gCamCapability[cameraId]) {
-        rc = initCapabilities(cameraId);
-        if (rc < 0) {
-            pthread_mutex_unlock(&g_camlock);
-            return rc;
-        }
-    }
-
-    switch(gCamCapability[cameraId]->position) {
-    case CAM_POSITION_BACK:
-        info->facing = CAMERA_FACING_BACK;
-        break;
-
-    case CAM_POSITION_FRONT:
-        info->facing = CAMERA_FACING_FRONT;
-        break;
-
-    default:
-        ALOGE("%s:Unknown position type for camera id:%d", __func__, cameraId);
-        rc = BAD_VALUE;
-        break;
-    }
-
-    info->orientation = gCamCapability[cameraId]->sensor_mount_angle;
+    p_info = get_cam_info(cameraId);
+    memcpy(info, p_info, sizeof (struct camera_info));
     property_set("camera.4k2k.enable", "0");
     pthread_mutex_unlock(&g_camlock);
     return rc;
diff --git a/QCamera2/HAL/QCamera2HWI.h b/QCamera2/HAL/QCamera2HWI.h
index 88d49bc..44eb60f 100644
--- a/QCamera2/HAL/QCamera2HWI.h
+++ b/QCamera2/HAL/QCamera2HWI.h
@@ -223,7 +223,7 @@ public:
     int openCamera(struct hw_device_t **hw_device);
 
     static int getCapabilities(int cameraId, struct camera_info *info);
-    static int initCapabilities(int cameraId);
+    static int initCapabilities(int cameraId,mm_camera_vtbl_t *cameraHandle);
 
     // Implementation of QCameraAllocator
     virtual QCameraMemory *allocateStreamBuf(cam_stream_type_t stream_type,
diff --git a/QCamera2/stack/common/mm_camera_interface.h b/QCamera2/stack/common/mm_camera_interface.h
index 64ef495..7ca99f9 100644
--- a/QCamera2/stack/common/mm_camera_interface.h
+++ b/QCamera2/stack/common/mm_camera_interface.h
@@ -622,5 +622,5 @@ uint8_t get_num_of_cameras();
 
 /* return reference pointer of camera vtbl */
 mm_camera_vtbl_t * camera_open(uint8_t camera_idx);
-
+struct camera_info *get_cam_info(int camera_id);
 #endif /*__MM_CAMERA_INTERFACE_H__*/
diff --git a/QCamera2/stack/mm-camera-interface/inc/mm_camera.h b/QCamera2/stack/mm-camera-interface/inc/mm_camera.h
index 412d612..d0e74fe 100644
--- a/QCamera2/stack/mm-camera-interface/inc/mm_camera.h
+++ b/QCamera2/stack/mm-camera-interface/inc/mm_camera.h
@@ -33,7 +33,7 @@
 #include <cam_semaphore.h>
 
 #include "mm_camera_interface.h"
-
+#include <hardware/camera.h>
 /**********************************************************************************
 * Data structure declare
 ***********************************************************************************/
@@ -390,6 +390,7 @@ typedef struct {
     int8_t num_cam;
     char video_dev_name[MM_CAMERA_MAX_NUM_SENSORS][MM_CAMERA_DEV_NAME_LEN];
     mm_camera_obj_t *cam_obj[MM_CAMERA_MAX_NUM_SENSORS];
+    struct camera_info info[MM_CAMERA_MAX_NUM_SENSORS];
 } mm_camera_ctrl_t;
 
 /**********************************************************************************
diff --git a/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c b/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c
index 0e6b677..fef2090 100644
--- a/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c
+++ b/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c
@@ -43,7 +43,7 @@
 
 static pthread_mutex_t g_intf_lock = PTHREAD_MUTEX_INITIALIZER;
 
-static mm_camera_ctrl_t g_cam_ctrl = {0, {{0}}, {0}};
+static mm_camera_ctrl_t g_cam_ctrl = {0, {{0}}, {0}, {{0}}};
 
 static pthread_mutex_t g_handler_lock = PTHREAD_MUTEX_INITIALIZER;
 static uint16_t g_handler_history_count = 0; /* history count for handler */
@@ -1174,6 +1174,93 @@ static int32_t mm_camera_intf_unmap_stream_buf(uint32_t camera_handle,
 }
 
 /*===========================================================================
+ * FUNCTION   : get_sensor_info
+ *
+ * DESCRIPTION: get sensor info like facing(back/front) and mount angle
+ *
+ * PARAMETERS :
+ *
+ * RETURN     :
+ *==========================================================================*/
+void get_sensor_info()
+{
+    int rc = 0;
+    int dev_fd = 0;
+    struct media_device_info mdev_info;
+    int num_media_devices = 0;
+    uint8_t num_cameras = 0;
+
+    CDBG("%s : E", __func__);
+    /* lock the mutex */
+    while (1) {
+        char dev_name[32];
+        int num_entities;
+        snprintf(dev_name, sizeof(dev_name), "/dev/media%d", num_media_devices);
+        dev_fd = open(dev_name, O_RDWR | O_NONBLOCK);
+        if (dev_fd <= 0) {
+            CDBG("Done discovering media devices\n");
+            break;
+        }
+        num_media_devices++;
+        memset(&mdev_info, 0, sizeof(mdev_info));
+        rc = ioctl(dev_fd, MEDIA_IOC_DEVICE_INFO, &mdev_info);
+        if (rc < 0) {
+            CDBG_ERROR("Error: ioctl media_dev failed: %s\n", strerror(errno));
+            close(dev_fd);
+            dev_fd = 0;
+            num_cameras = 0;
+            break;
+        }
+
+        if(strncmp(mdev_info.model,  MSM_CONFIGURATION_NAME, sizeof(mdev_info.model)) != 0) {
+            close(dev_fd);
+            dev_fd = 0;
+            continue;
+        }
+
+        num_entities = 1;
+        while (1) {
+            struct media_entity_desc entity;
+            unsigned long temp;
+            unsigned int mount_angle;
+            unsigned int facing;
+
+            memset(&entity, 0, sizeof(entity));
+            entity.id = num_entities++;
+            rc = ioctl(dev_fd, MEDIA_IOC_ENUM_ENTITIES, &entity);
+            if (rc < 0) {
+                CDBG("Done enumerating media entities\n");
+                rc = 0;
+                break;
+            }
+            if(entity.type == MEDIA_ENT_T_V4L2_SUBDEV &&
+                entity.group_id == MSM_CAMERA_SUBDEV_SENSOR) {
+                temp = entity.flags;
+                mount_angle = (temp & 0xFF) * 90;
+                facing = (temp >> 8);
+                ALOGD("index = %d flag = %x mount_angle = %d facing = %d\n"
+                    , num_cameras, (unsigned int)temp, (unsigned int)mount_angle,
+                    (unsigned int)facing);
+                g_cam_ctrl.info[num_cameras].facing = facing;
+                g_cam_ctrl.info[num_cameras].orientation = mount_angle;
+                num_cameras++;
+                continue;
+            }
+        }
+
+        CDBG("%s: dev_info[id=%d,name='%s']\n",
+            __func__, num_cameras, g_cam_ctrl.video_dev_name[num_cameras]);
+
+        close(dev_fd);
+        dev_fd = 0;
+    }
+
+    /* unlock the mutex */
+    CDBG("%s: num_cameras=%d\n", __func__, g_cam_ctrl.num_cam);
+    return;
+}
+
+/*===========================================================================
  * FUNCTION   : get_num_of_cameras
  *
  * DESCRIPTION: get number of cameras
@@ -1246,12 +1333,17 @@ uint8_t get_num_of_cameras()
     }
     g_cam_ctrl.num_cam = num_cameras;
 
+    get_sensor_info();
     /* unlock the mutex */
     pthread_mutex_unlock(&g_intf_lock);
     CDBG("%s: num_cameras=%d\n", __func__, g_cam_ctrl.num_cam);
     return g_cam_ctrl.num_cam;
 }
 
+struct camera_info *get_cam_info(int camera_id)
+{
+    return &g_cam_ctrl.info[camera_id];
+}
 /* camera ops v-table */
 static mm_camera_ops_t mm_camera_ops = {
     .query_capability = mm_camera_intf_query_capability,
-- 
1.8.3.1

