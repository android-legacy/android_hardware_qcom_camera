From a8af7a7a4c46ebeee8908171287230973b16ea0b Mon Sep 17 00:00:00 2001
From: Kamen Kirov <kkirov@codeaurora.org>
Date: Thu, 10 Oct 2013 13:51:45 +0300
Subject: [PATCH 053/176] QCamera2: Multiple HAL changes for dual JPEG encondig

1. Do not wait for the previous JPEG job to complete before
starting the next one.
2. Add ability to flush individual jobs out of the ongoing JPEG queue.
3. Add an overloaded flushNodes() queue method which supports flushing
by user provided data.
4. Set the main and thumb image dimensions and rotation when creating
JPEG session.
5. Add the EXIF object reference for each JPEG job to the job data,
destroy it
when flushing the job node.
6. Create a new node data release function for the inputRawQ.

Change-Id: Ie7c5b0beafd90726fccb3d6fc16e0453a024fd23
---
 QCamera2/HAL/QCameraPostProc.cpp | 210 +++++++++++++++++++++++++++------------
 QCamera2/HAL/QCameraPostProc.h   |   4 +
 QCamera2/util/QCameraQueue.cpp   |  43 ++++++++
 QCamera2/util/QCameraQueue.h     |   2 +
 4 files changed, 193 insertions(+), 66 deletions(-)

diff --git a/QCamera2/HAL/QCameraPostProc.cpp b/QCamera2/HAL/QCameraPostProc.cpp
index 1ea5111..ec09bb8 100644
--- a/QCamera2/HAL/QCameraPostProc.cpp
+++ b/QCamera2/HAL/QCameraPostProc.cpp
@@ -65,10 +65,11 @@ QCameraPostProcessor::QCameraPostProcessor(QCamera2HardwareInterface *cam_ctrl)
       m_ongoingPPQ(releaseOngoingPPData, this),
       m_inputJpegQ(releaseJpegData, this),
       m_ongoingJpegQ(releaseJpegData, this),
-      m_inputRawQ(releaseSaveJobData, this),
+      m_inputRawQ(releaseRawData, this),
       mRawBurstCount(0),
       mSaveFrmCnt(0),
-      mUseSaveProc(false)
+      mUseSaveProc(false),
+      mUseJpegBurst(false)
 {
     memset(&mJpegHandle, 0, sizeof(mJpegHandle));
 }
@@ -265,6 +266,40 @@ int32_t QCameraPostProcessor::getJpegEncodingConfig(mm_jpeg_encode_params_t& enc
     int32_t ret = NO_ERROR;
     camera_memory_t *jpeg_mem = NULL;
 
+    char prop[PROPERTY_VALUE_MAX];
+    property_get("persist.camera.jpeg_burst", prop, "0");
+    mUseJpegBurst = (atoi(prop) > 0) && !mUseSaveProc;
+    encode_parm.burst_mode = mUseJpegBurst;
+
+    cam_rect_t crop;
+    memset(&crop, 0, sizeof(cam_rect_t));
+    main_stream->getCropInfo(crop);
+
+    cam_dimension_t src_dim, dst_dim;
+    memset(&src_dim, 0, sizeof(cam_dimension_t));
+    memset(&dst_dim, 0, sizeof(cam_dimension_t));
+    main_stream->getFrameDimension(src_dim);
+
+    bool hdr_output_crop = m_parent->mParameters.isHDROutputCropEnabled();
+    if (hdr_output_crop && crop.height) {
+        dst_dim.height = crop.height;
+    } else {
+        dst_dim.height = src_dim.height;
+    }
+    if (hdr_output_crop && crop.width) {
+        dst_dim.width = crop.width;
+    } else {
+        dst_dim.width = src_dim.width;
+    }
+
+    // set rotation only when no online rotation or offline pp rotation is done before
+    if (!m_parent->needRotationReprocess()) {
+        encode_parm.rotation = m_parent->getJpegRotation();
+    }
+
+    encode_parm.main_dim.src_dim = src_dim;
+    encode_parm.main_dim.dst_dim = dst_dim;
+
     encode_parm.jpeg_cb = mJpegCB;
     encode_parm.userdata = mJpegUserData;
 
@@ -340,8 +375,25 @@ int32_t QCameraPostProcessor::getJpegEncodingConfig(mm_jpeg_encode_params_t& enc
         cam_format_t img_fmt_thumb = CAM_FORMAT_YUV_420_NV12;
         thumb_stream->getFormat(img_fmt_thumb);
         encode_parm.thumb_color_format = getColorfmtFromImgFmt(img_fmt_thumb);
+
+        memset(&crop, 0, sizeof(cam_rect_t));
+        thumb_stream->getCropInfo(crop);
+        memset(&src_dim, 0, sizeof(cam_dimension_t));
+        thumb_stream->getFrameDimension(src_dim);
+        encode_parm.thumb_dim.src_dim = src_dim;
+        m_parent->getThumbnailSize(encode_parm.thumb_dim.dst_dim);
+        int rotation = m_parent->getJpegRotation();
+        if (rotation == 90 || rotation ==270) {
+            // swap dimension if rotation is 90 or 270
+            int32_t temp = encode_parm.thumb_dim.dst_dim.height;
+            encode_parm.thumb_dim.dst_dim.height =
+                encode_parm.thumb_dim.dst_dim.width;
+            encode_parm.thumb_dim.dst_dim.width = temp;
+          }
+        encode_parm.thumb_dim.crop = crop;
     }
 
+
     // allocate output buf for jpeg encoding
     if (m_pJpegOutputMem != NULL) {
         m_pJpegOutputMem->deallocate();
@@ -355,25 +407,35 @@ int32_t QCameraPostProcessor::getJpegEncodingConfig(mm_jpeg_encode_params_t& enc
         ALOGE("%s : No memory for m_pJpegOutputMem", __func__);
         goto on_error;
     }
-    ret = m_pJpegOutputMem->allocate(1, main_offset.frame_len);
+
+    encode_parm.num_dst_bufs = 1;
+    if (mUseJpegBurst) {
+        encode_parm.num_dst_bufs = 2;
+    }
+
+    ret = m_pJpegOutputMem->allocate(encode_parm.num_dst_bufs, main_offset.frame_len);
     if(ret != OK) {
         ret = NO_MEMORY;
         ALOGE("%s : No memory for m_pJpegOutputMem", __func__);
         goto on_error;
     }
-    jpeg_mem = m_pJpegOutputMem->getMemory(0, false);
-    if (NULL == jpeg_mem) {
-        ret = NO_MEMORY;
-        ALOGE("%s : initHeapMem for jpeg, ret = NO_MEMORY", __func__);
-        goto on_error;
+
+    for (int i = 0; i < (int)encode_parm.num_dst_bufs; i++) {
+        jpeg_mem = m_pJpegOutputMem->getMemory(i, false);
+        if (NULL == jpeg_mem) {
+          ret = NO_MEMORY;
+          ALOGE("%s : initHeapMem for jpeg, ret = NO_MEMORY", __func__);
+          goto on_error;
+        }
+
+        encode_parm.dest_buf[i].index = i;
+        encode_parm.dest_buf[i].buf_size = jpeg_mem->size;
+        encode_parm.dest_buf[i].buf_vaddr = (uint8_t *)jpeg_mem->data;
+        encode_parm.dest_buf[i].fd = m_pJpegOutputMem->getFd(i);
+        encode_parm.dest_buf[i].format = MM_JPEG_FMT_YUV;
+        encode_parm.dest_buf[i].offset = main_offset;
     }
-    encode_parm.num_dst_bufs = 1;
-    encode_parm.dest_buf[0].index = 0;
-    encode_parm.dest_buf[0].buf_size = jpeg_mem->size;
-    encode_parm.dest_buf[0].buf_vaddr = (uint8_t *)jpeg_mem->data;
-    encode_parm.dest_buf[0].fd = m_pJpegOutputMem->getFd(0);
-    encode_parm.dest_buf[0].format = MM_JPEG_FMT_YUV;
-    encode_parm.dest_buf[0].offset = main_offset;
+
 
     ALOGV("%s : X", __func__);
     return NO_ERROR;
@@ -590,15 +652,8 @@ int32_t QCameraPostProcessor::processJpegEvt(qcamera_jpeg_evt_payload_t *evt)
         m_inputSaveQ.enqueue((void *) saveData);
         m_saveProcTh.sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);
     } else {
-
-        // find job by jobId
-        qcamera_jpeg_data_t *job = findJpegJobByJobId(evt->jobId);
-
-        if (job == NULL) {
-            ALOGE("%s: Cannot find jpeg job by jobId(%d)", __func__, evt->jobId);
-            rc = BAD_VALUE;
-            goto end;
-        }
+        // Release jpeg job data
+        m_ongoingJpegQ.flushNodes(matchJobId, (void*)&evt->jobId);
 
         ALOGD("[KPI Perf] %s : jpeg job %d", __func__, evt->jobId);
 
@@ -654,12 +709,6 @@ end:
                 jpeg_mem = NULL;
             }
         }
-
-        // release internal data for jpeg job
-        if (job != NULL) {
-            releaseJpegJobData(job);
-            free(job);
-        }
     }
 
     // wait up data proc thread to do next job,
@@ -801,6 +850,8 @@ void QCameraPostProcessor::releaseJpegData(void *data, void *user_data)
     QCameraPostProcessor *pme = (QCameraPostProcessor *)user_data;
     if (NULL != pme) {
         pme->releaseJpegJobData((qcamera_jpeg_data_t *)data);
+        ALOGD("%s : Rleased job ID %u", __func__,
+            ((qcamera_jpeg_data_t *)data)->jobId);
     }
 }
 
@@ -943,6 +994,11 @@ void QCameraPostProcessor::releaseJpegJobData(qcamera_jpeg_data_t *job)
             free(job->src_frame);
             job->src_frame = NULL;
         }
+
+        if (NULL != job->pJpegExifObj) {
+            delete job->pJpegExifObj;
+            job->pJpegExifObj = NULL;
+        }
     }
     ALOGV("%s: X", __func__);
 }
@@ -988,6 +1044,33 @@ void QCameraPostProcessor::releaseSaveJobData(void *data, void *user_data)
 }
 
 /*===========================================================================
+ * FUNCTION   : releaseRawData
+ *
+ * DESCRIPTION: function to release internal resources in store jobs
+ *
+ * PARAMETERS :
+ *   @job     : ptr to save job struct
+ *
+ * RETURN     : None
+ *
+ *==========================================================================*/
+void QCameraPostProcessor::releaseRawData(void *data, void *user_data)
+{
+    ALOGV("%s: E", __func__);
+
+    QCameraPostProcessor *pme = (QCameraPostProcessor *) user_data;
+    if (NULL == pme) {
+        ALOGE("%s: Invalid postproc handle", __func__);
+        return;
+    }
+    mm_camera_super_buf_t *super_buf = (mm_camera_super_buf_t *) data;
+    pme->releaseSuperBuf(super_buf);
+
+    ALOGV("%s: X", __func__);
+}
+
+
+/*===========================================================================
  * FUNCTION   : getColorfmtFromImgFmt
  *
  * DESCRIPTION: function to return jpeg color format based on its image format
@@ -1200,6 +1283,9 @@ int32_t QCameraPostProcessor::encodeData(qcamera_jpeg_data_t *jpeg_job_data,
     jpg_job.encode_job.session_id = mJpegSessionId;
     jpg_job.encode_job.src_index = main_frame->buf_idx;
     jpg_job.encode_job.dst_index = 0;
+    if (mUseJpegBurst) {
+      jpg_job.encode_job.dst_index = -1;
+    }
 
     cam_dimension_t src_dim;
     memset(&src_dim, 0, sizeof(cam_dimension_t));
@@ -1249,15 +1335,12 @@ int32_t QCameraPostProcessor::encodeData(qcamera_jpeg_data_t *jpeg_job_data,
     jpg_job.encode_job.main_dim.crop = crop;
 
     // get exif data
-    if (m_pJpegExifObj != NULL) {
-        delete m_pJpegExifObj;
-        m_pJpegExifObj = NULL;
-    }
-    m_pJpegExifObj = m_parent->getExifData();
-    if (m_pJpegExifObj != NULL) {
-        jpg_job.encode_job.exif_info.exif_data = m_pJpegExifObj->getEntries();
+    QCameraExif *pJpegExifObj = m_parent->getExifData();
+    jpeg_job_data->pJpegExifObj = pJpegExifObj;
+    if (pJpegExifObj != NULL) {
+        jpg_job.encode_job.exif_info.exif_data = pJpegExifObj->getEntries();
         jpg_job.encode_job.exif_info.numOfEntries =
-          m_pJpegExifObj->getNumOfEntries();
+            pJpegExifObj->getNumOfEntries();
     }
 
     // set rotation only when no online rotation or offline pp rotation is done before
@@ -1538,13 +1621,7 @@ void *QCameraPostProcessor::dataSaveRoutine(void *data)
                     continue;
                 }
 
-                // find job by jobId
-                qcamera_jpeg_data_t *job = pme->findJpegJobByJobId(job_data->jobId);
-
-                if (job == NULL) {
-                    ALOGE("%s: Cannot find jpeg job by jobId(%d)", __func__, job_data->jobId);
-                    continue;
-                }
+                pme->m_ongoingJpegQ.flushNodes(matchJobId, (void*)&job_data->jobId);
 
                 ALOGD("[KPI Perf] %s : jpeg job %d", __func__, job_data->jobId);
 
@@ -1600,8 +1677,6 @@ void *QCameraPostProcessor::dataSaveRoutine(void *data)
                 }
 
 end:
-                pme->releaseJpegJobData(job);
-                free(job);
                 free(job_data);
             }
             break;
@@ -1725,27 +1800,23 @@ void *QCameraPostProcessor::dataProcessRoutine(void *data)
             {
                 ALOGV("%s: Do next job, active is %d", __func__, is_active);
                 if (is_active == TRUE) {
-                    // check if there is any ongoing jpeg jobs
-                    if (pme->m_ongoingJpegQ.isEmpty()) {
-                        // no ongoing jpeg job, we are fine to send jpeg encoding job
-                        qcamera_jpeg_data_t *jpeg_job =
-                            (qcamera_jpeg_data_t *)pme->m_inputJpegQ.dequeue();
-
-                        if (NULL != jpeg_job) {
-                            // add into ongoing jpeg job Q
-                            pme->m_ongoingJpegQ.enqueue((void *)jpeg_job);
-                            ret = pme->encodeData(jpeg_job, needNewSess);
-                            if (NO_ERROR != ret) {
-                                // dequeue the last one
-                                pme->m_ongoingJpegQ.dequeue(false);
-
-                                pme->releaseJpegJobData(jpeg_job);
-                                free(jpeg_job);
-                                pme->sendEvtNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
-                            }
-                        }
+                    qcamera_jpeg_data_t *jpeg_job =
+                        (qcamera_jpeg_data_t *)pme->m_inputJpegQ.dequeue();
+
+                    if (NULL != jpeg_job) {
+                      // add into ongoing jpeg job Q
+                      pme->m_ongoingJpegQ.enqueue((void *)jpeg_job);
+                      ret = pme->encodeData(jpeg_job, needNewSess);
+                      if (NO_ERROR != ret) {
+                        // dequeue the last one
+                        pme->m_ongoingJpegQ.dequeue(false);
+                        pme->releaseJpegJobData(jpeg_job);
+                        free(jpeg_job);
+                        pme->sendEvtNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
+                      }
                     }
 
+
                     // process raw data if any
                     mm_camera_super_buf_t *super_buf =
                         (mm_camera_super_buf_t *)pme->m_inputRawQ.dequeue();
@@ -1922,6 +1993,13 @@ int32_t QCameraPostProcessor::setYUVFrameInfo(mm_camera_super_buf_t *recvd_frame
     return BAD_VALUE;
 }
 
+bool QCameraPostProcessor::matchJobId(void *data, void *, void *match_data)
+{
+  qcamera_jpeg_data_t * job = (qcamera_jpeg_data_t *) data;
+  uint32_t job_id = *((uint32_t *) match_data);
+  return job->jobId == job_id;
+}
+
 
 /*===========================================================================
  * FUNCTION   : QCameraExif
diff --git a/QCamera2/HAL/QCameraPostProc.h b/QCamera2/HAL/QCameraPostProc.h
index e5e216a..7c251d7 100644
--- a/QCamera2/HAL/QCameraPostProc.h
+++ b/QCamera2/HAL/QCameraPostProc.h
@@ -45,6 +45,7 @@ typedef struct {
     uint32_t client_hdl;             // handle of jpeg client (obtained when open jpeg)
     mm_camera_super_buf_t *src_frame;// source frame (need to be returned back to kernel after done)
     mm_camera_super_buf_t *src_reproc_frame; // original source frame for reproc if not NULL
+    QCameraExif *pJpegExifObj;
 } qcamera_jpeg_data_t;
 
 typedef struct {
@@ -134,6 +135,7 @@ private:
                                   int32_t cb_status);
     void releaseJpegJobData(qcamera_jpeg_data_t *job);
     static void releaseSaveJobData(void *data, void *user_data);
+    static void releaseRawData(void *data, void *user_data);
     int32_t processRawImageImpl(mm_camera_super_buf_t *recvd_frame);
 
     static void releaseJpegData(void *data, void *user_data);
@@ -144,6 +146,7 @@ private:
     static void *dataSaveRoutine(void *data);
 
     int32_t setYUVFrameInfo(mm_camera_super_buf_t *recvd_frame);
+    static bool matchJobId(void *data, void *user_data, void *match_data);
 
 private:
     QCamera2HardwareInterface *m_parent;
@@ -172,6 +175,7 @@ private:
     uint32_t mSaveFrmCnt;               // save frame counter
     static const char *STORE_LOCATION;  // path for storing buffers
     bool mUseSaveProc;                  // use store thread
+    bool mUseJpegBurst;                 // use jpeg burst encoding mode
 };
 
 }; // namespace qcamera
diff --git a/QCamera2/util/QCameraQueue.cpp b/QCamera2/util/QCameraQueue.cpp
index c6bb94e..4c6585d 100644
--- a/QCamera2/util/QCameraQueue.cpp
+++ b/QCamera2/util/QCameraQueue.cpp
@@ -292,4 +292,47 @@ void QCameraQueue::flushNodes(match_fn match){
     pthread_mutex_unlock(&m_lock);
 }
 
+/*===========================================================================
+ * FUNCTION   : flushNodes
+ *
+ * DESCRIPTION: flush only specific nodes, depending on
+ *              the given matching function.
+ *
+ * PARAMETERS :
+ *   @match   : matching function
+ *
+ * RETURN     : None
+ *==========================================================================*/
+void QCameraQueue::flushNodes(match_fn_data match, void *match_data){
+    camera_q_node* node = NULL;
+    struct cam_list *head = NULL;
+    struct cam_list *pos = NULL;
+
+    if ( NULL == match ) {
+        return;
+    }
+
+    pthread_mutex_lock(&m_lock);
+    head = &m_head.list;
+    pos = head->next;
+
+    while(pos != head) {
+        node = member_of(pos, camera_q_node, list);
+        pos = pos->next;
+        if ( match(node->data, m_userData, match_data) ) {
+            cam_list_del_node(&node->list);
+            m_size--;
+
+            if (NULL != node->data) {
+                if (m_dataFn) {
+                    m_dataFn(node->data, m_userData);
+                }
+                free(node->data);
+            }
+            free(node);
+        }
+    }
+    pthread_mutex_unlock(&m_lock);
+}
+
 }; // namespace qcamera
diff --git a/QCamera2/util/QCameraQueue.h b/QCamera2/util/QCameraQueue.h
index 6e2c759..809e342 100644
--- a/QCamera2/util/QCameraQueue.h
+++ b/QCamera2/util/QCameraQueue.h
@@ -35,6 +35,7 @@
 
 namespace qcamera {
 
+typedef bool (*match_fn_data)(void *data, void *user_data, void *match_data);
 typedef void (*release_data_fn)(void* data, void *user_data);
 typedef bool (*match_fn)(void *data, void *user_data);
 
@@ -47,6 +48,7 @@ public:
     bool enqueueWithPriority(void *data);
     void flush();
     void flushNodes(match_fn match);
+    void flushNodes(match_fn_data match, void *spec_data);
     void* dequeue(bool bFromHead = true);
     bool isEmpty();
 private:
-- 
1.8.3.1

