From bd430e04423ea44099ff51c262b30637f3ace6e0 Mon Sep 17 00:00:00 2001
From: Kamen Kirov <kkirov@codeaurora.org>
Date: Wed, 6 Nov 2013 11:38:24 +0200
Subject: [PATCH 072/176] QCamera2: Add jpeg output memory optimization

Avoid memcopying the jpeg output image in the callback routine.

Change-Id: I3a0218c889826742318c6654835c354875cbbfa9
---
 QCamera2/HAL/QCameraPostProc.cpp               | 66 +++++++++++++++++++++-----
 QCamera2/HAL/QCameraPostProc.h                 |  2 +
 QCamera2/stack/common/mm_jpeg_interface.h      |  2 +
 QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c | 48 +++++++++++++++++++
 mm-image-codec/qomx_core/QOMX_JpegExtensions.h | 31 ++++++++++++
 5 files changed, 138 insertions(+), 11 deletions(-)

diff --git a/QCamera2/HAL/QCameraPostProc.cpp b/QCamera2/HAL/QCameraPostProc.cpp
index c9ff1f2..4de0a2b 100644
--- a/QCamera2/HAL/QCameraPostProc.cpp
+++ b/QCamera2/HAL/QCameraPostProc.cpp
@@ -78,7 +78,8 @@ QCameraPostProcessor::QCameraPostProcessor(QCamera2HardwareInterface *cam_ctrl)
       mSaveFrmCnt(0),
       mUseSaveProc(false),
       mUseJpegBurst(false),
-      mNewJpegSessionNeeded(true)
+      mNewJpegSessionNeeded(true),
+      mJpegMemOpt(true)
 {
     memset(&mJpegHandle, 0, sizeof(mJpegHandle));
     memset(&m_pJpegOutputMem, 0, sizeof(m_pJpegOutputMem));
@@ -333,6 +334,7 @@ int32_t QCameraPostProcessor::getJpegEncodingConfig(mm_jpeg_encode_params_t& enc
 {
     ALOGV("%s : E", __func__);
     int32_t ret = NO_ERROR;
+    uint32_t out_size;
 
     char prop[PROPERTY_VALUE_MAX];
     property_get("persist.camera.jpeg_burst", prop, "0");
@@ -459,13 +461,19 @@ int32_t QCameraPostProcessor::getJpegEncodingConfig(mm_jpeg_encode_params_t& enc
     if (mUseJpegBurst) {
         encode_parm.num_dst_bufs = MAX_JPEG_BURST;
     }
-
+    encode_parm.get_memory = NULL;
+    out_size = main_offset.frame_len;
+    if (mJpegMemOpt) {
+        encode_parm.get_memory = getJpegMemory;
+        out_size = sizeof(omx_jpeg_ouput_buf_t);
+    }
     for (int i = 0; i < (int)encode_parm.num_dst_bufs; i++) {
         if (m_pJpegOutputMem[i] != NULL)
           free(m_pJpegOutputMem[i]);
-
+        omx_jpeg_ouput_buf_t omx_out_buf;
+        omx_out_buf.handle = this;
         // allocate output buf for jpeg encoding
-        m_pJpegOutputMem[i] = malloc(main_offset.frame_len);
+        m_pJpegOutputMem[i] = malloc(out_size);
 
         if (NULL == m_pJpegOutputMem[i]) {
           ret = NO_MEMORY;
@@ -473,6 +481,11 @@ int32_t QCameraPostProcessor::getJpegEncodingConfig(mm_jpeg_encode_params_t& enc
           goto on_error;
         }
 
+        if (mJpegMemOpt) {
+            memcpy(m_pJpegOutputMem[i], &omx_out_buf, sizeof(omx_out_buf));
+        }
+
+
         encode_parm.dest_buf[i].index = i;
         encode_parm.dest_buf[i].buf_size = main_offset.frame_len;
         encode_parm.dest_buf[i].buf_vaddr = (uint8_t *)m_pJpegOutputMem[i];
@@ -698,6 +711,7 @@ int32_t QCameraPostProcessor::processJpegEvt(qcamera_jpeg_evt_payload_t *evt)
 
     int32_t rc = NO_ERROR;
     camera_memory_t *jpeg_mem = NULL;
+    omx_jpeg_ouput_buf_t *jpeg_out = NULL;
 
     if (mUseSaveProc && m_parent->isLongshotEnabled()) {
         qcamera_jpeg_evt_payload_t *saveData = ( qcamera_jpeg_evt_payload_t * ) malloc(sizeof(qcamera_jpeg_evt_payload_t));
@@ -734,14 +748,20 @@ int32_t QCameraPostProcessor::processJpegEvt(qcamera_jpeg_evt_payload_t *evt)
                                   evt->jobId);
         ALOGD("%s: Dump jpeg_size=%d", __func__, evt->out_data.buf_filled_len);
 
-        // alloc jpeg memory to pass to upper layer
-        jpeg_mem = m_parent->mGetMemory(-1, evt->out_data.buf_filled_len, 1, m_parent->mCallbackCookie);
-        if (NULL == jpeg_mem) {
-            rc = NO_MEMORY;
-            ALOGE("%s : getMemory for jpeg, ret = NO_MEMORY", __func__);
-            goto end;
+        if (!mJpegMemOpt) {
+            // alloc jpeg memory to pass to upper layer
+            jpeg_mem = m_parent->mGetMemory(-1, evt->out_data.buf_filled_len,
+                1, m_parent->mCallbackCookie);
+            if (NULL == jpeg_mem) {
+                rc = NO_MEMORY;
+                ALOGE("%s : getMemory for jpeg, ret = NO_MEMORY", __func__);
+                goto end;
+            }
+            memcpy(jpeg_mem->data, evt->out_data.buf_vaddr, evt->out_data.buf_filled_len);
+        } else {
+            jpeg_out  = (omx_jpeg_ouput_buf_t*) evt->out_data.buf_vaddr;
+            jpeg_mem = (camera_memory_t *)jpeg_out->mem_hdl;
         }
-        memcpy(jpeg_mem->data, evt->out_data.buf_vaddr, evt->out_data.buf_filled_len);
 
         ALOGE("%s : Calling upperlayer callback to store JPEG image", __func__);
         qcamera_release_data_t release_data;
@@ -2114,6 +2134,30 @@ bool QCameraPostProcessor::matchJobId(void *data, void *, void *match_data)
   return job->jobId == job_id;
 }
 
+/*===========================================================================
+ * FUNCTION   : getJpegMemory
+ *
+ * DESCRIPTION: buffer allocation function
+ *   to pass to jpeg interface
+ *
+ * PARAMETERS :
+ *   @out_buf : buffer descriptor struct
+ *
+ * RETURN     : int32_t type of status
+ *              NO_ERROR  -- success
+ *              none-zero failure code
+ *==========================================================================*/
+int QCameraPostProcessor::getJpegMemory(omx_jpeg_ouput_buf_t *out_buf)
+{
+    ALOGD("%s: Allocating jpeg out buffer of size: %d", __func__, out_buf->size);
+    QCameraPostProcessor *procInst = (QCameraPostProcessor *) out_buf->handle;
+    camera_memory_t *cam_mem = procInst->m_parent->mGetMemory(-1, out_buf->size,
+        1, procInst->m_parent->mCallbackCookie);
+    out_buf->mem_hdl = cam_mem;
+    out_buf->vaddr = cam_mem->data;
+
+    return 0;
+}
 
 /*===========================================================================
  * FUNCTION   : QCameraExif
diff --git a/QCamera2/HAL/QCameraPostProc.h b/QCamera2/HAL/QCameraPostProc.h
index ab6351e..05fd3c0 100644
--- a/QCamera2/HAL/QCameraPostProc.h
+++ b/QCamera2/HAL/QCameraPostProc.h
@@ -153,6 +153,7 @@ private:
 
     int32_t setYUVFrameInfo(mm_camera_super_buf_t *recvd_frame);
     static bool matchJobId(void *data, void *user_data, void *match_data);
+    static int getJpegMemory(omx_jpeg_ouput_buf_t *out_buf);
 
 private:
     QCamera2HardwareInterface *m_parent;
@@ -183,6 +184,7 @@ private:
     bool mUseSaveProc;                  // use store thread
     bool mUseJpegBurst;                 // use jpeg burst encoding mode
     uint8_t mNewJpegSessionNeeded;
+    bool mJpegMemOpt;
 };
 
 }; // namespace qcamera
diff --git a/QCamera2/stack/common/mm_jpeg_interface.h b/QCamera2/stack/common/mm_jpeg_interface.h
index e51776f..2b31e4c 100644
--- a/QCamera2/stack/common/mm_jpeg_interface.h
+++ b/QCamera2/stack/common/mm_jpeg_interface.h
@@ -179,6 +179,8 @@ typedef struct {
   /* enable encoder burst mode */
   int8_t burst_mode;
 
+  /* get memory function ptr */
+  int (*get_memory)( omx_jpeg_ouput_buf_t *p_out_buf);
 } mm_jpeg_encode_params_t;
 
 typedef struct {
diff --git a/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c b/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
index 5c516b1..ebbefb6 100644
--- a/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
+++ b/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
@@ -477,6 +477,47 @@ OMX_ERRORTYPE mm_jpeg_encoding_mode(
   return rc;
 }
 
+/** mm_jpeg_mem_ops:
+ *
+ *  Arguments:
+ *    @p_session: job session
+ *
+ *  Return:
+ *       OMX error values
+ *
+ *  Description:
+ *       Configure the serial or parallel encoding
+ *       mode
+ *
+ **/
+OMX_ERRORTYPE mm_jpeg_mem_ops(
+  mm_jpeg_job_session_t* p_session)
+{
+  OMX_ERRORTYPE rc = 0;
+  int32_t i = 0;
+  OMX_INDEXTYPE indextype;
+  QOMX_MEM_OPS mem_ops;
+  int32_t totalSize = 0;
+  mm_jpeg_encode_params_t *p_params = &p_session->params;
+  mm_jpeg_encode_job_t *p_jobparams = &p_session->encode_job;
+
+  mem_ops.get_memory = p_params->get_memory;
+
+  rc = OMX_GetExtensionIndex(p_session->omx_handle,
+    QOMX_IMAGE_EXT_MEM_OPS_NAME, &indextype);
+  if (rc != OMX_ErrorNone) {
+    CDBG_ERROR("%s:%d] Failed", __func__, __LINE__);
+    return rc;
+  }
+
+  rc = OMX_SetParameter(p_session->omx_handle, indextype, &mem_ops);
+  if (rc != OMX_ErrorNone) {
+    CDBG_ERROR("%s:%d] Failed", __func__, __LINE__);
+    return rc;
+  }
+  return rc;
+}
+
 /** mm_jpeg_metadata:
  *
  *  Arguments:
@@ -979,6 +1020,13 @@ OMX_ERRORTYPE mm_jpeg_session_config_main(mm_jpeg_job_session_t *p_session)
     return rc;
   }
 
+  /* set the mem ops */
+  rc = mm_jpeg_mem_ops(p_session);
+  if (OMX_ErrorNone != rc) {
+    CDBG_ERROR("%s: config mem ops failed", __func__);
+    return rc;
+  }
+
   return rc;
 }
 
diff --git a/mm-image-codec/qomx_core/QOMX_JpegExtensions.h b/mm-image-codec/qomx_core/QOMX_JpegExtensions.h
index 3244856..562427e 100644
--- a/mm-image-codec/qomx_core/QOMX_JpegExtensions.h
+++ b/mm-image-codec/qomx_core/QOMX_JpegExtensions.h
@@ -58,6 +58,7 @@ typedef enum {
 #define QOMX_IMAGE_EXT_WORK_BUFFER_NAME      "OMX.QCOM.image.exttype.workbuffer"
 #define QOMX_IMAGE_EXT_METADATA_NAME      "OMX.QCOM.image.exttype.metadata"
 #define QOMX_IMAGE_EXT_META_ENC_KEY_NAME      "OMX.QCOM.image.exttype.metaEncKey"
+#define QOMX_IMAGE_EXT_MEM_OPS_NAME      "OMX.QCOM.image.exttype.mem_ops"
 
 /** QOMX_IMAGE_EXT_INDEXTYPE
 *  This enum is an extension of the OMX_INDEXTYPE enum and
@@ -91,6 +92,9 @@ typedef enum {
   //Name: OMX.QCOM.image.exttype.metaEncKey
   QOMX_IMAGE_EXT_META_ENC_KEY = 0x07F00009,
 
+  //Name: OMX.QCOM.image.exttype.memOps
+  QOMX_IMAGE_EXT_MEM_OPS = 0x07F0000A,
+
 } QOMX_IMAGE_EXT_INDEXTYPE;
 
 /** QOMX_BUFFER_INFO
@@ -252,6 +256,33 @@ typedef enum {
   OMX_Parallel_Encoding
 } QOMX_ENCODING_MODE;
 
+
+/**omx_jpeg_ouput_buf_t
+*  Structure describing jpeg output buffer
+*  @handle - Handle to the containing class
+*  @mem_hdl - Handle to camera memory struct
+*  @vaddr - Buffer address
+*  @size - Buffer size
+*  @fd - file descriptor
+**/
+typedef struct {
+  void *handle;
+  void *mem_hdl;
+  int8_t isheap;
+  int size; /*input*/
+  void *vaddr;
+  int fd;
+} omx_jpeg_ouput_buf_t;
+
+/** QOMX_MEM_OPS
+* Structure holding the function pointers to
+* buffer memory operations
+* @get_memory - function to allocate buffer memory
+**/
+typedef struct {
+  int (*get_memory)( omx_jpeg_ouput_buf_t *p_out_buf);
+} QOMX_MEM_OPS;
+
 #ifdef __cplusplus
  }
 #endif
-- 
1.8.3.1

