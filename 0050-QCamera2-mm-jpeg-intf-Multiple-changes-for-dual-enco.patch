From 8ce062578698e514fed68b13cb92446db812bade Mon Sep 17 00:00:00 2001
From: Kamen Kirov <kkirov@codeaurora.org>
Date: Thu, 10 Oct 2013 13:38:38 +0300
Subject: [PATCH 050/176] QCamera2: mm-jpeg-intf: Multiple changes for dual
 encoding

1. Add new fields to encode params for burst mode control (dual encoding),
image sizes and rotation.
2. Add functionality to create two OMX sessions, when the JPEG mode
is burst and arch is MSM8974.
3. Support two encoding jobs in parallel.
4. Add ability to get the output JPEG buffer from a pool of available
buffers.

Change-Id: I1808a20a5aa2151926f4aeb57f97b473c1cdd5db
---
 QCamera2/stack/common/mm_jpeg_interface.h          |  16 +-
 QCamera2/stack/mm-jpeg-interface/Android.mk        |   6 +
 QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h     |  22 +-
 QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c     | 328 +++++++++++++++++----
 .../stack/mm-jpeg-interface/src/mm_jpeg_queue.c    |  20 ++
 5 files changed, 325 insertions(+), 67 deletions(-)

diff --git a/QCamera2/stack/common/mm_jpeg_interface.h b/QCamera2/stack/common/mm_jpeg_interface.h
index 147e706..d0d8a36 100644
--- a/QCamera2/stack/common/mm_jpeg_interface.h
+++ b/QCamera2/stack/common/mm_jpeg_interface.h
@@ -164,6 +164,18 @@ typedef struct {
   jpeg_encode_callback_t jpeg_cb;
   void* userdata;
 
+  /* thumbnail dimension */
+  mm_jpeg_dim_t thumb_dim;
+
+  /* rotation informaiton */
+  int rotation;
+
+  /* main image dimension */
+  mm_jpeg_dim_t main_dim;
+
+  /* enable encoder burst mode */
+  int8_t burst_mode;
+
 } mm_jpeg_encode_params_t;
 
 typedef struct {
@@ -189,8 +201,8 @@ typedef struct {
 
 typedef struct {
   /* active indices of the buffers for encoding */
-  uint32_t src_index;
-  uint32_t dst_index;
+  int32_t src_index;
+  int32_t dst_index;
   uint32_t thumb_index;
   mm_jpeg_dim_t thumb_dim;
 
diff --git a/QCamera2/stack/mm-jpeg-interface/Android.mk b/QCamera2/stack/mm-jpeg-interface/Android.mk
index de87f42..8b32d79 100644
--- a/QCamera2/stack/mm-jpeg-interface/Android.mk
+++ b/QCamera2/stack/mm-jpeg-interface/Android.mk
@@ -20,6 +20,12 @@ ifeq ($(strip $(TARGET_USES_ION)),true)
     LOCAL_CFLAGS += -DUSE_ION
 endif
 
+ifeq ($(call is-board-platform-in-list, msm8974),true)
+    LOCAL_CFLAGS+= -DMM_JPEG_CONCURRENT_SESSIONS_COUNT=2
+else
+    LOCAL_CFLAGS+= -DMM_JPEG_CONCURRENT_SESSIONS_COUNT=1
+endif
+
 LOCAL_SRC_FILES := \
     src/mm_jpeg_queue.c \
     src/mm_jpeg_exif.c \
diff --git a/QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h b/QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h
index 1dfe50b..737af21 100644
--- a/QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h
+++ b/QCamera2/stack/mm-jpeg-interface/inc/mm_jpeg.h
@@ -45,6 +45,8 @@
 #define MM_JPEG_MAX_SESSION 10
 #define MAX_EXIF_TABLE_ENTRIES 50
 #define MAX_JPEG_SIZE 20000000
+#define MAX_OMX_HANDLES (5)
+
 
 /** mm_jpeg_abort_state_t:
  *  @MM_JPEG_ABORT_NONE: Abort is not issued
@@ -62,7 +64,7 @@ typedef enum {
 
 /* define max num of supported concurrent jpeg jobs by OMX engine.
  * Current, only one per time */
-#define NUM_MAX_JPEG_CNCURRENT_JOBS 1
+#define NUM_MAX_JPEG_CNCURRENT_JOBS 2
 
 #define JOB_ID_MAGICVAL 0x1
 #define JOB_HIST_MAX 10000
@@ -257,7 +259,7 @@ typedef enum {
   MM_JPEG_CMD_TYPE_MAX
 } mm_jpeg_cmd_type_t;
 
-typedef struct {
+typedef struct mm_jpeg_job_session {
   uint32_t client_hdl;           /* client handler */
   uint32_t jobId;                /* job ID */
   uint32_t sessionId;            /* session ID */
@@ -313,6 +315,16 @@ typedef struct {
 
   OMX_EVENTTYPE omxEvent;
   int event_pending;
+
+  struct mm_jpeg_job_session *next_session;
+
+  uint32_t curr_out_buf_idx;
+
+  uint32_t num_omx_sessions;
+  OMX_BOOL auto_out_buf;
+
+  mm_jpeg_queue_t *session_handle_q;
+  mm_jpeg_queue_t *out_buf_q;
 } mm_jpeg_job_session_t;
 
 typedef struct {
@@ -358,11 +370,14 @@ typedef struct mm_jpeg_obj_t {
   pthread_mutex_t job_lock;                       /* job lock */
   mm_jpeg_job_cmd_thread_t job_mgr;               /* job mgr thread including todo_q*/
   mm_jpeg_queue_t ongoing_job_q;                  /* queue for ongoing jobs */
-  buffer_t ionBuffer;
+  buffer_t ionBuffer[MM_JPEG_CONCURRENT_SESSIONS_COUNT];
+
 
   /* Max pic dimension for work buf calc*/
   int32_t max_pic_w;
   int32_t max_pic_h;
+
+  int work_buf_cnt;
 } mm_jpeg_obj;
 
 /** mm_jpeg_pending_func_t:
@@ -418,6 +433,7 @@ uint8_t mm_jpeg_util_get_index_by_handler(uint32_t handler);
 /* basic queue functions */
 extern int32_t mm_jpeg_queue_init(mm_jpeg_queue_t* queue);
 extern int32_t mm_jpeg_queue_enq(mm_jpeg_queue_t* queue, void* node);
+extern int32_t mm_jpeg_queue_enq_head(mm_jpeg_queue_t* queue, void* node);
 extern void* mm_jpeg_queue_deq(mm_jpeg_queue_t* queue);
 extern int32_t mm_jpeg_queue_deinit(mm_jpeg_queue_t* queue);
 extern int32_t mm_jpeg_queue_flush(mm_jpeg_queue_t* queue);
diff --git a/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c b/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
index 65ac966..484e9b5 100644
--- a/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
+++ b/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg.c
@@ -57,6 +57,9 @@ OMX_ERRORTYPE mm_jpeg_event_handler(OMX_HANDLETYPE hComponent,
 
 static int32_t mm_jpegenc_destroy_job(mm_jpeg_job_session_t *p_session);
 static void mm_jpegenc_job_done(mm_jpeg_job_session_t *p_session);
+mm_jpeg_job_q_node_t* mm_jpeg_queue_remove_job_by_dst_ptr(
+  mm_jpeg_queue_t* queue, void * dst_ptr);
+static OMX_ERRORTYPE mm_jpeg_session_configure(mm_jpeg_job_session_t *p_session);
 
 /** mm_jpeg_session_send_buffers:
  *
@@ -261,6 +264,8 @@ OMX_ERRORTYPE mm_jpeg_session_create(mm_jpeg_job_session_t* p_session)
 {
   OMX_ERRORTYPE rc = OMX_ErrorNone;
   mm_jpeg_cirq_t *p_cirq = NULL;
+  mm_jpeg_obj *my_obj = (mm_jpeg_obj *) p_session->jpeg_obj;
+  int i = 0;
 
   pthread_mutex_init(&p_session->lock, NULL);
   pthread_cond_init(&p_session->cond, NULL);
@@ -273,19 +278,22 @@ OMX_ERRORTYPE mm_jpeg_session_create(mm_jpeg_job_session_t* p_session)
   p_session->encode_pid = -1;
   p_session->config = OMX_FALSE;
   p_session->exif_count_local = 0;
+  p_session->auto_out_buf = OMX_FALSE;
 
   p_session->omx_callbacks.EmptyBufferDone = mm_jpeg_ebd;
   p_session->omx_callbacks.FillBufferDone = mm_jpeg_fbd;
   p_session->omx_callbacks.EventHandler = mm_jpeg_event_handler;
-  rc = OMX_GetHandle(&p_session->omx_handle,
-    "OMX.qcom.image.jpeg.encoder",
-    (void *)p_session,
-    &p_session->omx_callbacks);
 
+
+  rc = OMX_GetHandle(&p_session->omx_handle,
+      "OMX.qcom.image.jpeg.encoder",
+      (void *)p_session,
+      &p_session->omx_callbacks);
   if (OMX_ErrorNone != rc) {
     CDBG_ERROR("%s:%d] OMX_GetHandle failed (%d)", __func__, __LINE__, rc);
     return rc;
   }
+
   return rc;
 }
 
@@ -342,6 +350,12 @@ void mm_jpeg_session_destroy(mm_jpeg_job_session_t* p_session)
 
   pthread_mutex_destroy(&p_session->lock);
   pthread_cond_destroy(&p_session->cond);
+
+  // Destroy next session
+  if (p_session->next_session) {
+    mm_jpeg_session_destroy(p_session->next_session);
+  }
+
   CDBG("%s:%d] X", __func__, __LINE__);
 }
 
@@ -368,10 +382,9 @@ OMX_ERRORTYPE mm_jpeg_session_config_main_buffer_offset(
   QOMX_YUV_FRAME_INFO frame_info;
   int32_t totalSize = 0;
   mm_jpeg_encode_params_t *p_params = &p_session->params;
-  mm_jpeg_encode_job_t *p_jobparams = &p_session->encode_job;
 
   mm_jpeg_buf_t *p_src_buf =
-    &p_params->src_main_buf[p_jobparams->src_index];
+    &p_params->src_main_buf[0];
 
   memset(&frame_info, 0x0, sizeof(QOMX_YUV_FRAME_INFO));
 
@@ -546,10 +559,10 @@ OMX_ERRORTYPE mm_jpeg_session_config_ports(mm_jpeg_job_session_t* p_session)
 {
   OMX_ERRORTYPE ret = OMX_ErrorNone;
   mm_jpeg_encode_params_t *p_params = &p_session->params;
-  mm_jpeg_encode_job_t *p_jobparams = &p_session->encode_job;
+  OMX_CONFIG_ROTATIONTYPE rotate;
 
   mm_jpeg_buf_t *p_src_buf =
-    &p_params->src_main_buf[p_jobparams->src_index];
+    &p_params->src_main_buf[0];
 
   p_session->inputPort.nPortIndex = 0;
   p_session->outputPort.nPortIndex = 1;
@@ -577,9 +590,9 @@ OMX_ERRORTYPE mm_jpeg_session_config_ports(mm_jpeg_job_session_t* p_session)
   }
 
   p_session->inputPort.format.image.nFrameWidth =
-    p_jobparams->main_dim.src_dim.width;
+    p_params->main_dim.src_dim.width;
   p_session->inputPort.format.image.nFrameHeight =
-    p_jobparams->main_dim.src_dim.height;
+    p_params->main_dim.src_dim.height;
   p_session->inputPort.format.image.nStride =
     p_src_buf->offset.mp[0].stride;
   p_session->inputPort.format.image.nSliceHeight =
@@ -587,7 +600,7 @@ OMX_ERRORTYPE mm_jpeg_session_config_ports(mm_jpeg_job_session_t* p_session)
   p_session->inputPort.format.image.eColorFormat =
     map_jpeg_format(p_params->color_format);
   p_session->inputPort.nBufferSize =
-    p_params->src_main_buf[p_jobparams->src_index].buf_size;
+    p_params->src_main_buf[0/*p_jobparams->src_index*/].buf_size;
   p_session->inputPort.nBufferCountActual = p_params->num_src_bufs;
   ret = OMX_SetParameter(p_session->omx_handle, OMX_IndexParamPortDefinition,
     &p_session->inputPort);
@@ -598,11 +611,11 @@ OMX_ERRORTYPE mm_jpeg_session_config_ports(mm_jpeg_job_session_t* p_session)
 
   if (p_session->params.encode_thumbnail) {
     mm_jpeg_buf_t *p_tmb_buf =
-      &p_params->src_thumb_buf[p_jobparams->thumb_index];
+      &p_params->src_thumb_buf[0];
     p_session->inputTmbPort.format.image.nFrameWidth =
-      p_jobparams->thumb_dim.src_dim.width;
+      p_params->thumb_dim.src_dim.width;
     p_session->inputTmbPort.format.image.nFrameHeight =
-      p_jobparams->thumb_dim.src_dim.height;
+      p_params->thumb_dim.src_dim.height;
     p_session->inputTmbPort.format.image.nStride =
       p_tmb_buf->offset.mp[0].stride;
     p_session->inputTmbPort.format.image.nSliceHeight =
@@ -610,7 +623,7 @@ OMX_ERRORTYPE mm_jpeg_session_config_ports(mm_jpeg_job_session_t* p_session)
     p_session->inputTmbPort.format.image.eColorFormat =
       map_jpeg_format(p_params->thumb_color_format);
     p_session->inputTmbPort.nBufferSize =
-      p_params->src_thumb_buf[p_jobparams->thumb_index].buf_size;
+      p_params->src_thumb_buf[0].buf_size;
     p_session->inputTmbPort.nBufferCountActual = p_params->num_tmb_bufs;
     ret = OMX_SetParameter(p_session->omx_handle, OMX_IndexParamPortDefinition,
       &p_session->inputTmbPort);
@@ -640,7 +653,7 @@ OMX_ERRORTYPE mm_jpeg_session_config_ports(mm_jpeg_job_session_t* p_session)
   }
 
   p_session->outputPort.nBufferSize =
-    p_params->dest_buf[p_jobparams->dst_index].buf_size;
+    p_params->dest_buf[0].buf_size;
   p_session->outputPort.nBufferCountActual = p_params->num_dst_bufs;
   ret = OMX_SetParameter(p_session->omx_handle, OMX_IndexParamPortDefinition,
     &p_session->outputPort);
@@ -649,6 +662,19 @@ OMX_ERRORTYPE mm_jpeg_session_config_ports(mm_jpeg_job_session_t* p_session)
     return ret;
   }
 
+  /* set rotation */
+  memset(&rotate, 0, sizeof(rotate));
+  rotate.nPortIndex = 1;
+  rotate.nRotation = p_params->rotation;
+  ret = OMX_SetConfig(p_session->omx_handle, OMX_IndexConfigCommonRotate,
+      &rotate);
+  if (OMX_ErrorNone != ret) {
+    CDBG_ERROR("%s:%d] Error %d", __func__, __LINE__, ret);
+    return ret;
+  }
+  CDBG("%s:%d] Set rotation to %d at port_idx = %d", __func__, __LINE__,
+      (int)p_params->rotation, (int)rotate.nPortIndex);
+
   return ret;
 }
 
@@ -864,7 +890,6 @@ OMX_ERRORTYPE mm_jpeg_session_config_main_crop(mm_jpeg_job_session_t *p_session)
 OMX_ERRORTYPE mm_jpeg_session_config_main(mm_jpeg_job_session_t *p_session)
 {
   OMX_ERRORTYPE rc = OMX_ErrorNone;
-  mm_jpeg_encode_job_t *p_jobparams = &p_session->encode_job;
 
   /* config port */
   CDBG("%s:%d] config port", __func__, __LINE__);
@@ -935,11 +960,12 @@ OMX_ERRORTYPE mm_jpeg_session_config_common(mm_jpeg_job_session_t *p_session)
     CDBG_ERROR("%s:%d] Error %d", __func__, __LINE__, rc);
     return rc;
   }
+
   CDBG("%s:%d] Num of exif entries passed from HAL: %d", __func__, __LINE__,
       (int)p_jobparams->exif_info.numOfEntries);
   if (p_jobparams->exif_info.numOfEntries > 0) {
-     rc = OMX_SetConfig(p_session->omx_handle, exif_idx,
-      &p_jobparams->exif_info);
+    rc = OMX_SetConfig(p_session->omx_handle, exif_idx,
+        &p_jobparams->exif_info);
     if (OMX_ErrorNone != rc) {
       CDBG_ERROR("%s:%d] Error %d", __func__, __LINE__, rc);
       return rc;
@@ -949,7 +975,7 @@ OMX_ERRORTYPE mm_jpeg_session_config_common(mm_jpeg_job_session_t *p_session)
   if (NULL != p_jobparams->p_metadata) {
     exif_info.numOfEntries = 0;
     exif_info.exif_data = &p_session->exif_info_local[0];
-  process_meta_data(p_jobparams->p_metadata, &exif_info, &p_jobparams->cam_exif_params);
+    process_meta_data(p_jobparams->p_metadata, &exif_info, &p_jobparams->cam_exif_params);
     /* After Parse metadata */
     p_session->exif_count_local = exif_info.numOfEntries;
 
@@ -1025,6 +1051,13 @@ OMX_BOOL mm_jpeg_session_abort(mm_jpeg_job_session_t *p_session)
   }
   p_session->abort_state = MM_JPEG_ABORT_DONE;
   pthread_mutex_unlock(&p_session->lock);
+
+
+  // Abort next session
+  if (p_session->next_session) {
+    mm_jpeg_session_abort(p_session->next_session);
+  }
+
   CDBG("%s:%d] X", __func__, __LINE__);
   return 0;
 }
@@ -1136,7 +1169,6 @@ static OMX_ERRORTYPE mm_jpeg_session_configure(mm_jpeg_job_session_t *p_session)
 {
   OMX_ERRORTYPE ret = OMX_ErrorNone;
   mm_jpeg_encode_params_t *p_params = &p_session->params;
-  mm_jpeg_encode_job_t *p_jobparams = &p_session->encode_job;
   mm_jpeg_obj *my_obj = (mm_jpeg_obj *)p_session->jpeg_obj;
 
   CDBG("%s:%d] E ", __func__, __LINE__);
@@ -1286,15 +1318,52 @@ int32_t mm_jpeg_process_encoding_job(mm_jpeg_obj *my_obj, mm_jpeg_job_q_node_t*
   OMX_ERRORTYPE ret = OMX_ErrorNone;
   mm_jpeg_job_session_t *p_session = NULL;
   mm_jpeg_job_q_node_t *node = NULL;
+  OMX_HANDLETYPE omx_handle = NULL;
+  uint32_t buf_idx;
 
   /* check if valid session */
   p_session = mm_jpeg_get_session(my_obj, job_node->enc_info.job_id);
   if (NULL == p_session) {
     CDBG_ERROR("%s:%d] invalid job id %x", __func__, __LINE__,
-      job_node->enc_info.job_id);
+        job_node->enc_info.job_id);
     return -1;
   }
 
+  CDBG_HIGH("%s:%d] before dequeue session %d",
+                __func__, __LINE__, ret);
+
+  /* dequeue available omx handle */
+  p_session = mm_jpeg_queue_deq(p_session->session_handle_q);
+
+  if (NULL == p_session) {
+    CDBG_HIGH("%s:%d] No available sessions %d",
+          __func__, __LINE__, ret);
+    /* No available handles */
+    mm_jpeg_queue_enq_head(&my_obj->job_mgr.job_queue, job_node);
+
+    CDBG_HIGH("%s:%d]end enqueue %d",
+              __func__, __LINE__, ret);
+    return rc;
+
+  }
+
+  p_session->auto_out_buf = OMX_FALSE;
+  if (job_node->enc_info.encode_job.dst_index < 0) {
+    /* dequeue available output buffer idx */
+    buf_idx = (uint32_t)mm_jpeg_queue_deq(p_session->out_buf_q);
+
+    if (NULL == (void*)buf_idx) {
+      CDBG_ERROR("%s:%d] No available output buffers %d",
+          __func__, __LINE__, ret);
+      return OMX_ErrorUndefined;
+    }
+
+    buf_idx--;
+
+    job_node->enc_info.encode_job.dst_index = buf_idx;
+    p_session->auto_out_buf = OMX_TRUE;
+  }
+
   /* sent encode cmd to OMX, queue job into ongoing queue */
   rc = mm_jpeg_queue_enq(&my_obj->ongoing_job_q, job_node);
   if (rc) {
@@ -1486,6 +1555,8 @@ int32_t mm_jpeg_init(mm_jpeg_obj *my_obj)
 {
   int32_t rc = 0;
   uint32_t work_buf_size;
+  int i = 0;
+  int initial_workbufs_cnt = 1;
 
   /* init locks */
   pthread_mutex_init(&my_obj->job_lock, NULL);
@@ -1497,6 +1568,7 @@ int32_t mm_jpeg_init(mm_jpeg_obj *my_obj)
     return -1;
   }
 
+
   /* init job semaphore and launch jobmgr thread */
   CDBG("%s:%d] Launch jobmgr thread rc %d", __func__, __LINE__, rc);
   rc = mm_jpeg_jobmgr_thread_launch(my_obj);
@@ -1513,24 +1585,33 @@ int32_t mm_jpeg_init(mm_jpeg_obj *my_obj)
   }
   work_buf_size = CEILING64(my_obj->max_pic_w) *
     CEILING64(my_obj->max_pic_h) * 1.5;
-  my_obj->ionBuffer.size = CEILING32(work_buf_size);
-  CDBG_HIGH("Max picture size %d x %d, WorkBufSize = %ld",
-    my_obj->max_pic_w, my_obj->max_pic_h, my_obj->ionBuffer.size);
-
-  my_obj->ionBuffer.addr = (uint8_t *)buffer_allocate(&my_obj->ionBuffer, 1);
-  if (NULL == my_obj->ionBuffer.addr) {
-    mm_jpeg_jobmgr_thread_release(my_obj);
-    mm_jpeg_queue_deinit(&my_obj->ongoing_job_q);
-    pthread_mutex_destroy(&my_obj->job_lock);
-    CDBG_ERROR("%s:%d] Ion allocation failed",__func__, __LINE__);
-    return -1;
+  for (i = 0; i < initial_workbufs_cnt; i++) {
+    my_obj->ionBuffer[i].size = CEILING32(work_buf_size);
+    CDBG_HIGH("Max picture size %d x %d, WorkBufSize = %ld",
+        my_obj->max_pic_w, my_obj->max_pic_h, my_obj->ionBuffer[i].size);
+
+    my_obj->ionBuffer[i].addr = (uint8_t *)buffer_allocate(&my_obj->ionBuffer[i], 1);
+    if (NULL == my_obj->ionBuffer[i].addr) {
+      while (i--) {
+        buffer_deallocate(&my_obj->ionBuffer[i]);
+      }
+      mm_jpeg_jobmgr_thread_release(my_obj);
+      mm_jpeg_queue_deinit(&my_obj->ongoing_job_q);
+      pthread_mutex_destroy(&my_obj->job_lock);
+      CDBG_ERROR("%s:%d] Ion allocation failed",__func__, __LINE__);
+      return -1;
+    }
   }
 
+  my_obj->work_buf_cnt = i;
+
   /* load OMX */
   if (OMX_ErrorNone != OMX_Init()) {
     /* roll back in error case */
     CDBG_ERROR("%s:%d] OMX_Init failed (%d)", __func__, __LINE__, rc);
-    buffer_deallocate(&my_obj->ionBuffer);
+    for (i = 0; i < initial_workbufs_cnt; i++) {
+      buffer_deallocate(&my_obj->ionBuffer[i]);
+    }
     mm_jpeg_jobmgr_thread_release(my_obj);
     mm_jpeg_queue_deinit(&my_obj->ongoing_job_q);
     pthread_mutex_destroy(&my_obj->job_lock);
@@ -1554,6 +1635,7 @@ int32_t mm_jpeg_init(mm_jpeg_obj *my_obj)
 int32_t mm_jpeg_deinit(mm_jpeg_obj *my_obj)
 {
   int32_t rc = 0;
+  int i = 0;
 
   /* release jobmgr thread */
   rc = mm_jpeg_jobmgr_thread_release(my_obj);
@@ -1570,10 +1652,12 @@ int32_t mm_jpeg_deinit(mm_jpeg_obj *my_obj)
     CDBG_ERROR("%s:%d] Error", __func__, __LINE__);
   }
 
-  /*Release the ION buffer*/
-  rc = buffer_deallocate(&my_obj->ionBuffer);
-  if (0 != rc) {
-    CDBG_ERROR("%s:%d] Error releasing ION buffer", __func__, __LINE__);
+  for (i = 0; i < my_obj->work_buf_cnt; i++) {
+    /*Release the ION buffer*/
+    rc = buffer_deallocate(&my_obj->ionBuffer[i]);
+    if (0 != rc) {
+      CDBG_ERROR("%s:%d] Error releasing ION buffer", __func__, __LINE__);
+    }
   }
 
   /* destroy locks */
@@ -1657,6 +1741,7 @@ int32_t mm_jpeg_start_job(mm_jpeg_obj *my_obj,
   mm_jpeg_job_q_node_t* node = NULL;
   mm_jpeg_job_session_t *p_session = NULL;
   mm_jpeg_encode_job_t *p_jobparams  = &job->encode_job;
+  uint32_t q_size;
 
   *job_id = 0;
 
@@ -1680,8 +1765,8 @@ int32_t mm_jpeg_start_job(mm_jpeg_obj *my_obj,
     return rc;
   }
 
-  if ((p_jobparams->src_index >= p_session->params.num_src_bufs) ||
-    (p_jobparams->dst_index >= p_session->params.num_dst_bufs)) {
+  if ((p_jobparams->src_index >= (int32_t)p_session->params.num_src_bufs) ||
+    (p_jobparams->dst_index >= (int32_t)p_session->params.num_dst_bufs)) {
     CDBG_ERROR("%s:%d] invalid buffer indices", __func__, __LINE__);
     return rc;
   }
@@ -1702,11 +1787,15 @@ int32_t mm_jpeg_start_job(mm_jpeg_obj *my_obj,
   node->enc_info.client_handle = p_session->client_hdl;
   node->type = MM_JPEG_CMD_TYPE_JOB;
 
+
+
   rc = mm_jpeg_queue_enq(&my_obj->job_mgr.job_queue, node);
   if (0 == rc) {
-    cam_sem_post(&my_obj->job_mgr.job_sem);
+      cam_sem_post(&my_obj->job_mgr.job_sem);
   }
 
+  CDBG_ERROR("%s:%d] X", __func__, __LINE__);
+
   return rc;
 }
 
@@ -1794,7 +1883,12 @@ int32_t mm_jpeg_create_session(mm_jpeg_obj *my_obj,
   uint8_t clnt_idx = 0;
   int session_idx = -1;
   mm_jpeg_job_session_t *p_session = NULL;
+  mm_jpeg_job_session_t * p_prev_session = NULL;
   *p_session_id = 0;
+  unsigned int i = 0;
+  uint32_t num_omx_sessions;
+  uint32_t work_buf_size;
+  mm_jpeg_queue_t *p_session_handle_q, *p_out_buf_q;
 
   /* validate the parameters */
   if ((p_params->num_src_bufs > MM_JPEG_MAX_BUF)
@@ -1810,29 +1904,107 @@ int32_t mm_jpeg_create_session(mm_jpeg_obj *my_obj,
     return rc;
   }
 
-  session_idx = mm_jpeg_get_new_session_idx(my_obj, clnt_idx, &p_session);
-  if (session_idx < 0) {
-    CDBG_ERROR("%s:%d] invalid session id (%d)", __func__, __LINE__, session_idx);
-    return rc;
+  num_omx_sessions = 1;
+  if (p_params->burst_mode) {
+    num_omx_sessions = MM_JPEG_CONCURRENT_SESSIONS_COUNT;
   }
 
-  p_session->work_buffer = my_obj->ionBuffer;
+  work_buf_size = CEILING64(my_obj->max_pic_w) *
+      CEILING64(my_obj->max_pic_h) * 1.5;
+  for (i = my_obj->work_buf_cnt; i < num_omx_sessions; i++) {
+     my_obj->ionBuffer[i].size = CEILING32(work_buf_size);
+     CDBG_HIGH("Max picture size %d x %d, WorkBufSize = %ld",
+         my_obj->max_pic_w, my_obj->max_pic_h, my_obj->ionBuffer[i].size);
+
+     my_obj->ionBuffer[i].addr = (uint8_t *)buffer_allocate(&my_obj->ionBuffer[i], 1);
+     if (NULL == my_obj->ionBuffer[i].addr) {
+       CDBG_ERROR("%s:%d] Ion allocation failed",__func__, __LINE__);
+       return -1;
+     }
+  }
+  my_obj->work_buf_cnt = num_omx_sessions;
+
+  /* init omx handle queue */
+  p_session_handle_q = (mm_jpeg_queue_t *) malloc(sizeof(*p_session_handle_q));
+  if (NULL == p_session_handle_q) {
+    CDBG_ERROR("%s:%d] Error", __func__, __LINE__);
+    return -1;
+  }
+  rc = mm_jpeg_queue_init(p_session_handle_q);
+  if (0 != rc) {
+    CDBG_ERROR("%s:%d] Error", __func__, __LINE__);
+    return -1;
+  }
 
-  ret = mm_jpeg_session_create(p_session);
-  if (OMX_ErrorNone != ret) {
-    p_session->active = OMX_FALSE;
-    CDBG_ERROR("%s:%d] jpeg session create failed", __func__, __LINE__);
-    return rc;
+  /* init output buf queue */
+  p_out_buf_q = (mm_jpeg_queue_t *) malloc(sizeof(*p_out_buf_q));
+  if (NULL == p_session_handle_q) {
+    CDBG_ERROR("%s:%d] Error", __func__, __LINE__);
+    return -1;
   }
+  /* init omx handle queue */
+  rc = mm_jpeg_queue_init(p_out_buf_q);
+  if (0 != rc) {
+    CDBG_ERROR("%s:%d] Error", __func__, __LINE__);
+    return -1;
+  }
+
+  for (i = 0; i < num_omx_sessions; i++) {
+    session_idx = mm_jpeg_get_new_session_idx(my_obj, clnt_idx, &p_session);
+    if (session_idx < 0) {
+      CDBG_ERROR("%s:%d] invalid session id (%d)", __func__, __LINE__, session_idx);
+      return rc;
+    }
+
+    p_session->next_session = NULL;
 
-  *p_session_id = (JOB_ID_MAGICVAL << 24) | (session_idx << 8) | clnt_idx;
+    if (p_prev_session) {
+      p_prev_session->next_session = p_session;
+    }
+    p_prev_session = p_session;
+
+    p_session->work_buffer = my_obj->ionBuffer[i];
 
-  /*copy the params*/
-  p_session->params = *p_params;
-  p_session->client_hdl = client_hdl;
-  p_session->sessionId = *p_session_id;
-  p_session->jpeg_obj = (void*)my_obj; /* save a ptr to jpeg_obj */
-  CDBG("%s:%d] session id %x", __func__, __LINE__, *p_session_id);
+    ret = mm_jpeg_session_create(p_session);
+    if (OMX_ErrorNone != ret) {
+      p_session->active = OMX_FALSE;
+      CDBG_ERROR("%s:%d] jpeg session create failed", __func__, __LINE__);
+      return rc;
+    }
+
+    uint32_t session_id = (JOB_ID_MAGICVAL << 24) | (session_idx << 8) | clnt_idx;
+
+    if (!*p_session_id) {
+      *p_session_id = session_id;
+    }
+
+    /*copy the params*/
+    p_session->params = *p_params;
+    p_session->client_hdl = client_hdl;
+    p_session->sessionId = session_id;
+    p_session->jpeg_obj = (void*)my_obj; /* save a ptr to jpeg_obj */
+    p_session->session_handle_q = p_session_handle_q;
+    p_session->out_buf_q = p_out_buf_q;
+
+    mm_jpeg_queue_enq(p_session_handle_q, p_session);
+
+    if (OMX_FALSE == p_session->config) {
+      rc = mm_jpeg_session_configure(p_session);
+      if (rc) {
+        CDBG_ERROR("%s:%d] Error", __func__, __LINE__);
+        return rc;
+      }
+      p_session->config = OMX_TRUE;
+    }
+    p_session->num_omx_sessions = num_omx_sessions;
+
+    CDBG("%s:%d] session id %x", __func__, __LINE__, session_id);
+  }
+
+  // Queue the output buf indexes
+  for (i = 0; i < p_params->num_dst_bufs; i++) {
+    mm_jpeg_queue_enq(p_out_buf_q, (void *)(i+1));
+  }
 
   return rc;
 }
@@ -1896,6 +2068,14 @@ static void mm_jpegenc_job_done(mm_jpeg_job_session_t *p_session)
   }
   p_session->encoding = OMX_FALSE;
 
+  // Queue to available sessions
+  mm_jpeg_queue_enq(p_session->session_handle_q, p_session);
+
+  if (p_session->auto_out_buf) {
+    //Queue out buf index
+    mm_jpeg_queue_enq(p_session->out_buf_q, (void*)(p_session->encode_job.dst_index +1));
+  }
+
   /* wake up jobMgr thread to work on new job if there is any */
   cam_sem_post(&my_obj->job_mgr.job_sem);
 }
@@ -1921,6 +2101,7 @@ int32_t mm_jpeg_destroy_session(mm_jpeg_obj *my_obj,
   mm_jpeg_job_q_node_t *node = NULL;
   OMX_BOOL ret = OMX_FALSE;
   uint32_t session_id = 0;
+  mm_jpeg_job_session_t *p_cur_sess;
 
   if (NULL == p_session) {
     CDBG_ERROR("%s:%d] invalid session", __func__, __LINE__);
@@ -1950,13 +2131,35 @@ int32_t mm_jpeg_destroy_session(mm_jpeg_obj *my_obj,
   /* abort the current session */
   mm_jpeg_session_abort(p_session);
   mm_jpeg_session_destroy(p_session);
-  mm_jpeg_remove_session_idx(my_obj, session_id);
+
+  p_cur_sess = p_session;
+
+  do {
+    mm_jpeg_remove_session_idx(my_obj, p_cur_sess->sessionId);
+  } while (NULL != (p_cur_sess = p_cur_sess->next_session));
+
+
   pthread_mutex_unlock(&my_obj->job_lock);
 
+  while (NULL != mm_jpeg_queue_deq(p_session->session_handle_q))
+    ;
+  mm_jpeg_queue_deinit(p_session->session_handle_q);
+  free(p_session->session_handle_q);
+  p_session->session_handle_q = NULL;
+
+  while (NULL != mm_jpeg_queue_deq(p_session->out_buf_q))
+    ;
+  mm_jpeg_queue_deinit(p_session->out_buf_q);
+  free(p_session->out_buf_q);
+  p_session->out_buf_q = NULL;
+
+
   /* wake up jobMgr thread to work on new job if there is any */
   cam_sem_post(&my_obj->job_mgr.job_sem);
+
   CDBG("%s:%d] X", __func__, __LINE__);
 
+
   return rc;
 }
 
@@ -2126,20 +2329,21 @@ OMX_ERRORTYPE mm_jpeg_fbd(OMX_HANDLETYPE hComponent,
 
   p_session->fbd_count++;
   if (NULL != p_session->params.jpeg_cb) {
+
     p_session->job_status = JPEG_JOB_STATUS_DONE;
     output_buf.buf_filled_len = (uint32_t)pBuffer->nFilledLen;
     output_buf.buf_vaddr = pBuffer->pBuffer;
     output_buf.fd = 0;
-    CDBG("%s:%d] send jpeg callback %d", __func__, __LINE__,
-      p_session->job_status);
+    CDBG("%s:%d] send jpeg callback %d buf 0x%p len %u JobID %u", __func__, __LINE__,
+      p_session->job_status, pBuffer->pBuffer, pBuffer->nFilledLen, p_session->jobId);
     p_session->params.jpeg_cb(p_session->job_status,
       p_session->client_hdl,
       p_session->jobId,
       &output_buf,
       p_session->params.userdata);
 
-    /* remove from ready queue */
     mm_jpegenc_job_done(p_session);
+
   }
   pthread_mutex_unlock(&p_session->lock);
   CDBG("%s:%d] ", __func__, __LINE__);
diff --git a/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg_queue.c b/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg_queue.c
index b6d87aa..dcf1343 100644
--- a/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg_queue.c
+++ b/QCamera2/stack/mm-jpeg-interface/src/mm_jpeg_queue.c
@@ -60,6 +60,26 @@ int32_t mm_jpeg_queue_enq(mm_jpeg_queue_t* queue, void* data)
 
 }
 
+int32_t mm_jpeg_queue_enq_head(mm_jpeg_queue_t* queue, void* data)
+{
+    mm_jpeg_q_node_t* node =
+        (mm_jpeg_q_node_t *)malloc(sizeof(mm_jpeg_q_node_t));
+    if (NULL == node) {
+        CDBG_ERROR("%s: No memory for mm_jpeg_q_node_t", __func__);
+        return -1;
+    }
+
+    memset(node, 0, sizeof(mm_jpeg_q_node_t));
+    node->data = data;
+
+    pthread_mutex_lock(&queue->lock);
+    cam_list_insert_before_node(&node->list, &queue->head.list);
+    queue->size++;
+    pthread_mutex_unlock(&queue->lock);
+
+    return 0;
+}
+
 void* mm_jpeg_queue_deq(mm_jpeg_queue_t* queue)
 {
     mm_jpeg_q_node_t* node = NULL;
-- 
1.8.3.1

